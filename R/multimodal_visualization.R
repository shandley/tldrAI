# Multi-modal visualization interface for tldrAI
# This module provides a two-panel integrated interface combining
# text documentation and interactive visualizations.

#' Create a multi-modal interface for function documentation
#'
#' @description 
#' Creates a modern HTML-based two-panel interface with text documentation on the left
#' and tabbed visualizations on the right. The interface is designed to be both
#' visually appealing and informative.
#'
#' @param func_name Name of the function 
#' @param metadata Function metadata including arguments, description, etc.
#' @param response_text Formatted text response from AI
#' @param visualization_types Character vector of visualization types to include in tabs
#' @param theme Color theme to use ("light", "dark", or a custom list of colors)
#' @param width Overall width of the interface in pixels
#' @param height Overall height of the interface in pixels
#'
#' @return An htmlwidget object that can be displayed in RStudio or browser
#' 
#' @importFrom htmlwidgets createWidget
#' @importFrom htmltools tags div h1 h2 h3 p code pre tagList HTML
#' @export
create_multimodal_interface <- function(
  func_name, 
  metadata, 
  response_text,
  visualization_types = c("diagram", "data_flow", "code_highlight", "function_network"),
  theme = "light",
  width = NULL, 
  height = 600
) {
  # Check required packages
  if (!requireNamespace("htmltools", quietly = TRUE) || 
      !requireNamespace("htmlwidgets", quietly = TRUE)) {
    message("MultiModal visualization requires the 'htmltools' and 'htmlwidgets' packages.")
    message("Please install them with: install.packages(c(\"htmltools\", \"htmlwidgets\"))")
    return(NULL)
  }
  
  # Get theme colors
  colors <- get_theme_colors(theme)
  
  # Create the interface container
  interface <- htmltools::tags$div(
    class = "tldrAI-multimodal-container",
    style = paste0(
      "display: flex; flex-direction: row; font-family: 'Arial', sans-serif; ",
      "width: 100%; height: ", height, "px; ",
      "background-color: ", colors$background, "; ",
      "color: ", colors$text, "; ",
      "border-radius: 8px; overflow: hidden; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"
    ),
    
    # Header for the interface
    htmltools::tags$div(
      class = "tldrAI-header",
      style = paste0(
        "position: absolute; top: 0; left: 0; width: 100%; ",
        "background-color: ", colors$primary, "; ",
        "color: white; padding: 10px 20px; z-index: 10; ",
        "font-weight: bold; font-size: 16px; display: flex; ",
        "justify-content: space-between; align-items: center;"
      ),
      
      # Function name and package
      htmltools::tags$div(
        paste0(func_name, " - ", metadata$package, " package")
      ),
      
      # Generated info
      htmltools::tags$div(
        style = "font-size: 12px; font-weight: normal;",
        "Generated by tldrAI"
      )
    ),
    
    # Left panel - Text documentation
    htmltools::tags$div(
      class = "tldrAI-text-panel",
      style = paste0(
        "flex: 1; padding: 50px 20px 20px 20px; overflow-y: auto; ",
        "border-right: 1px solid ", colors$border, ";"
      ),
      format_response_text(response_text, colors)
    ),
    
    # Right panel - Visualization tabs
    htmltools::tags$div(
      class = "tldrAI-viz-panel",
      style = paste0(
        "flex: 1; padding: 50px 0 0 0; display: flex; flex-direction: column; ",
        "background-color: ", colors$background, ";"
      ),
      
      # Tab navigation
      htmltools::tags$div(
        class = "tldrAI-tabs",
        style = paste0(
          "display: flex; border-bottom: 1px solid ", colors$border, "; ",
          "background-color: ", colors$secondary, ";"
        ),
        create_tabs(visualization_types, colors)
      ),
      
      # Tab content area
      htmltools::tags$div(
        class = "tldrAI-tab-content",
        style = "flex: 1; overflow: hidden; position: relative;",
        create_tab_panels(func_name, metadata, visualization_types)
      )
    )
  )
  
  # Create widget with JavaScript for interactivity
  widget <- htmlwidgets::createWidget(
    name = "tldrAI_multimodal",
    x = list(
      interface = htmltools::doRenderTags(interface),
      tabs = visualization_types,
      func_name = func_name,
      metadata = metadata,
      theme = theme
    ),
    width = width,
    height = height,
    package = "tldrAI",
    dependencies = list(
      htmltools::htmlDependency(
        name = "tldrAI-multimodal",
        version = "0.1.0",
        src = system.file("htmlwidgets", package = "tldrAI"),
        script = "tldrAI-multimodal.js",
        stylesheet = "tldrAI-multimodal.css"
      )
    )
  )
  
  return(widget)
}

#' Format the AI response text for HTML display
#'
#' @param response_text Text response from AI
#' @param colors Theme colors list
#' @return HTML tags object with formatted content
#' @keywords internal
format_response_text <- function(response_text, colors) {
  # Check if the response is already in markdown format
  if (inherits(response_text, "html") || inherits(response_text, "shiny.tag")) {
    return(response_text)
  }
  
  # Create a div for the formatted content
  formatted_div <- htmltools::div(
    style = "font-family: Arial, sans-serif; padding: 0 5px;"
  )
  
  # Extract code blocks
  content <- extract_code_block(response_text)
  
  # Split the content by lines
  lines <- strsplit(content, "\n")[[1]]
  
  # Convert markdown to HTML directly
  if (requireNamespace("markdown", quietly = TRUE)) {
    try({
      html_content <- markdown::markdownToHTML(
        text = content,
        fragment.only = TRUE,
        options = c("use_xhtml")
      )
      formatted_div$children <- list(htmltools::HTML(html_content))
      return(formatted_div)
    }, silent = TRUE)
  }
  
  # Fallback: Process each line to create HTML elements
  html_elements <- list()
  in_code_block <- FALSE
  code_buffer <- character(0)
  
  for (i in seq_along(lines)) {
    line <- lines[i]
    
    # Check for top level headers (# Title)
    if (grepl("^#\\s+[^#]", line)) {
      if (in_code_block) {
        # Close previous code block
        html_elements <- c(html_elements, htmltools::tags$pre(
          style = paste0("background-color: ", colors$codeBackground, "; ",
                        "color: ", colors$codeText, "; ",
                        "padding: 10px; border-radius: 4px; overflow-x: auto;"),
          htmltools::tags$code(paste(code_buffer, collapse = "\n"))
        ))
        in_code_block <- FALSE
        code_buffer <- character(0)
      }
      
      title <- gsub("^#\\s+", "", line)
      html_elements <- c(html_elements, htmltools::tags$h1(
        style = paste0("color: ", colors$primary, "; margin-top: 20px; font-size: 1.5em;"),
        title
      ))
    }
    # Check for section headers (## Title)
    else if (grepl("^##\\s+", line)) {
      if (in_code_block) {
        # Close previous code block
        html_elements <- c(html_elements, htmltools::tags$pre(
          style = paste0("background-color: ", colors$codeBackground, "; ",
                        "color: ", colors$codeText, "; ",
                        "padding: 10px; border-radius: 4px; overflow-x: auto;"),
          htmltools::tags$code(paste(code_buffer, collapse = "\n"))
        ))
        in_code_block <- FALSE
        code_buffer <- character(0)
      }
      
      title <- gsub("^##\\s+", "", line)
      html_elements <- c(html_elements, htmltools::tags$h2(
        style = paste0("color: ", colors$secondary, "; margin-top: 15px; font-size: 1.3em;"),
        title
      ))
    }
    # Check for code blocks
    else if (grepl("^```", line)) {
      if (!in_code_block) {
        in_code_block <- TRUE
      } else {
        # Close code block
        html_elements <- c(html_elements, htmltools::tags$pre(
          style = paste0("background-color: ", colors$codeBackground, "; ",
                        "color: ", colors$codeText, "; ",
                        "padding: 10px; border-radius: 4px; overflow-x: auto;"),
          htmltools::tags$code(paste(code_buffer, collapse = "\n"))
        ))
        in_code_block <- FALSE
        code_buffer <- character(0)
      }
    }
    # Handle content within code blocks
    else if (in_code_block) {
      code_buffer <- c(code_buffer, line)
    }
    # Check for bullet points
    else if (grepl("^-\\s+", line)) {
      bullet_text <- gsub("^-\\s+", "", line)
      
      # Split by colon if present
      if (grepl(":", bullet_text)) {
        parts <- strsplit(bullet_text, ":\\s*", 2)[[1]]
        html_elements <- c(html_elements, htmltools::tags$p(
          style = "margin: 5px 0;",
          htmltools::tags$strong(style = paste0("color: ", colors$primary, ";"), paste0("• ", parts[1], ":")), 
          " ", parts[2]
        ))
      } else {
        html_elements <- c(html_elements, htmltools::tags$p(
          style = "margin: 5px 0;",
          htmltools::HTML(paste0("• ", bullet_text))
        ))
      }
    }
    # Handle inline code with backticks
    else if (grepl("`[^`]+`", line)) {
      # Replace inline code
      formatted_line <- gsub(
        "`([^`]+)`", 
        paste0("<code style='background-color: ", colors$codeBackground, "; ",
              "color: ", colors$codeText, "; padding: 2px 4px; border-radius: 3px;'>\\1</code>"), 
        line
      )
      html_elements <- c(html_elements, htmltools::tags$p(
        style = "margin: 7px 0;",
        htmltools::HTML(formatted_line)
      ))
    }
    # Regular text (skip empty lines)
    else if (nchar(trimws(line)) > 0) {
      html_elements <- c(html_elements, htmltools::tags$p(
        style = "margin: 7px 0;",
        line
      ))
    }
  }
  
  # In case there's still an open code block
  if (in_code_block && length(code_buffer) > 0) {
    html_elements <- c(html_elements, htmltools::tags$pre(
      style = paste0("background-color: ", colors$codeBackground, "; ",
                    "color: ", colors$codeText, "; ",
                    "padding: 10px; border-radius: 4px; overflow-x: auto;"),
      htmltools::tags$code(paste(code_buffer, collapse = "\n"))
    ))
  }
  
  formatted_div$children <- html_elements
  return(formatted_div)
}

#' Create tab buttons for the visualization panel
#'
#' @param visualization_types Vector of visualization types
#' @param colors Theme colors list
#' @return HTML tags list with tab buttons
#' @keywords internal
create_tabs <- function(visualization_types, colors) {
  tab_elements <- list()
  
  # Tab display names - more user-friendly than internal names
  tab_names <- list(
    diagram = "Function Diagram",
    flowchart = "Flowchart",
    data_flow = "Data Flow",
    function_network = "Function Network",
    code_highlight = "Code"
  )
  
  # Create a tab for each visualization type
  for (i in seq_along(visualization_types)) {
    type <- visualization_types[i]
    display_name <- tab_names[[type]] %||% capitalize(gsub("_", " ", type))
    
    # The first tab is active by default
    is_active <- i == 1
    active_class <- if(is_active) "tldrAI-tab-active" else ""
    
    tab_elements[[i]] <- htmltools::tags$div(
      class = paste("tldrAI-tab", active_class),
      id = paste0("tab-", type),
      `data-target` = paste0("panel-", type),
      style = paste0(
        "padding: 10px 15px; cursor: pointer; ",
        "border-bottom: 3px solid ", if(is_active) colors$accent else "transparent", "; ",
        "transition: all 0.3s ease;"
      ),
      display_name
    )
  }
  
  return(htmltools::tagList(tab_elements))
}

#' Create tab content panels for each visualization
#'
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param visualization_types Vector of visualization types
#' @return HTML tags list with tab panels
#' @keywords internal
create_tab_panels <- function(func_name, metadata, visualization_types) {
  panel_elements <- list()
  
  # Create a content panel for each visualization type
  for (i in seq_along(visualization_types)) {
    type <- visualization_types[i]
    
    # The first panel is visible by default
    is_visible <- i == 1
    display_style <- if(is_visible) "block" else "none"
    
    # Create panel with loading indicator
    panel_elements[[i]] <- htmltools::tags$div(
      class = "tldrAI-tab-panel",
      id = paste0("panel-", type),
      style = paste0(
        "position: absolute; top: 0; left: 0; width: 100%; height: 100%; ",
        "overflow: auto; padding: 15px; display: ", display_style, ";"
      ),
      
      # Loading indicator (replaced by actual visualization via JavaScript)
      htmltools::tags$div(
        class = "tldrAI-loading",
        style = paste0(
          "display: flex; flex-direction: column; ",
          "justify-content: center; align-items: center; ",
          "height: 100%; width: 100%;"
        ),
        
        htmltools::tags$div(
          style = paste0(
            "border: 3px solid #f3f3f3; border-top: 3px solid #3498db; ",
            "border-radius: 50%; width: 30px; height: 30px; animation: spin 2s linear infinite; ",
            "@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); }}"
          )
        ),
        
        htmltools::tags$p(
          style = "margin-top: 15px;",
          paste0("Loading ", gsub("_", " ", type), " visualization...")
        )
      ),
      
      # Placeholder for the visualization
      htmltools::tags$div(
        class = "tldrAI-visualization-container",
        id = paste0("viz-", type),
        `data-type` = type,
        `data-func` = func_name,
        style = "height: 100%; width: 100%;"
      )
    )
  }
  
  return(htmltools::tagList(panel_elements))
}

#' Get colors for the specified theme
#'
#' @param theme Theme name or custom color list
#' @return List of colors for the interface
#' @keywords internal
get_theme_colors <- function(theme) {
  if (is.list(theme)) {
    # Custom theme provided as a list
    defaults <- list(
      primary = "#4285F4",       # Primary color (headers, highlights)
      secondary = "#34A853",     # Secondary color (sub-headers)
      accent = "#FBBC05",        # Accent color (active tabs, buttons)
      background = "#FFFFFF",    # Background color
      secondaryBg = "#F5F5F5",   # Secondary background (tabs, panels)
      text = "#333333",          # Main text color
      secondaryText = "#666666", # Secondary text color
      border = "#DDDDDD",        # Border color
      codeBackground = "#F5F7F9", # Code block background
      codeText = "#24292E"       # Code text color
    )
    return(modifyList(defaults, theme))
  }
  
  # Predefined themes
  if (theme == "dark") {
    return(list(
      primary = "#4285F4",
      secondary = "#34A853",
      accent = "#FBBC05",
      background = "#1E1E1E",
      secondaryBg = "#2D2D2D",
      text = "#E8E8E8",
      secondaryText = "#BBBBBB",
      border = "#444444",
      codeBackground = "#2D2D30",
      codeText = "#D4D4D4"
    ))
  }
  
  # Default light theme
  return(list(
    primary = "#4285F4",
    secondary = "#34A853", 
    accent = "#FBBC05",
    background = "#FFFFFF",
    secondaryBg = "#F5F5F5",
    text = "#333333",
    secondaryText = "#666666",
    border = "#DDDDDD",
    codeBackground = "#F5F7F9",
    codeText = "#24292E"
  ))
}

#' Load a visualization into a tab panel
#'
#' @description Function called by JavaScript to generate visualization for a tab
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param vis_type Type of visualization to generate
#' @param theme Color theme to use ("light" or "dark")
#' @return HTML representation of the visualization
#' @export
load_visualization_tab <- function(func_name, metadata, vis_type, theme = "light") {
  # Debugging
  message(paste0("load_visualization_tab called for ", func_name, " type: ", vis_type))
  
  # Helper function for creating error messages
  create_error_message <- function(message, theme) {
    colors <- get_theme_colors(theme)
    return(htmltools::doRenderTags(htmltools::tags$div(
      class = "tldrAI-error",
      style = paste0("color: ", if(theme == "dark") "#FF6B6B" else "#D32F2F", "; text-align: center; padding: 20px;"),
      htmltools::tags$p(
        style = "font-size: 16px; margin-bottom: 10px;",
        paste0("Visualization error: ", message)
      ),
      htmltools::tags$p(
        "Using fallback visualization for now."
      )
    )))
  }
  
  # Get theme colors
  colors <- get_theme_colors(theme)
  
  # Select the appropriate visualization function based on type
  visualization <- NULL
  
  tryCatch({
    if (vis_type == "diagram") {
      message("Generating function diagram...")
      visualization <- generate_function_diagram_panel(func_name, metadata, theme)
    } else if (vis_type == "data_flow") {
      message("Generating data flow visualization...")
      visualization <- generate_data_transformation_panel(func_name, metadata, theme = theme)
    } else if (vis_type == "function_network") {
      message("Generating function network...")
      visualization <- generate_function_network_panel(func_name, metadata, theme)
    } else if (vis_type == "code_highlight") {
      message("Generating code highlight...")
      visualization <- generate_code_highlight_panel(func_name, metadata, theme)
    }
    message("Visualization generated successfully")
  }, error = function(e) {
    message(paste0("Error generating visualization: ", e$message))
    visualization <- NULL
  })
  
  # Convert visualization to HTML
  if (is.null(visualization)) {
    message("Visualization is NULL, returning error message")
    return(htmltools::doRenderTags(htmltools::tags$div(
      class = "tldrAI-error",
      style = paste0("color: ", if(theme == "dark") "#FF6B6B" else "#D32F2F", "; text-align: center; padding: 20px;"),
      htmltools::tags$p(
        style = "font-size: 16px; margin-bottom: 10px;",
        "Visualization failed to load"
      ),
      htmltools::tags$p(
        "Please ensure required packages are installed for this visualization type."
      )
    )))
  }
  
  # Handle different visualization types
  message(paste0("Visualization class: ", class(visualization)[1]))
  
  if (inherits(visualization, "htmlwidget")) {
    message("Processing htmlwidget...")
    # For htmlwidgets (like DiagrammeR, visNetwork), we need special handling
    temp_file <- tempfile(fileext = ".html")
    message(paste0("Saving widget to temporary file: ", temp_file))
    
    # Try/catch for saveWidget which can sometimes fail
    tryCatch({
      htmlwidgets::saveWidget(
        visualization, 
        file = temp_file, 
        selfcontained = TRUE
      )
      
      # Check if file exists and has content
      if (!file.exists(temp_file)) {
        message("Error: Saved widget file does not exist")
        return(create_error_message("Widget save failed", theme))
      }
      
      file_size <- file.info(temp_file)$size
      message(paste0("Widget file saved, size: ", file_size, " bytes"))
      
      if (file_size < 100) {
        message("Error: Widget file is too small, likely failed to save properly")
        return(create_error_message("Widget save failed - file too small", theme))
      }
      
      # Extract the widget contents (this is a workaround but necessary)
      # We need to extract the HTML content from the saved widget file
      widget_content <- readLines(temp_file, warn = FALSE)
      widget_content <- paste(widget_content, collapse = "\n")
      
      # Extract just the content portion we need
      widget_content <- gsub(".*<body>", "", widget_content)
      widget_content <- gsub("</body>.*", "", widget_content)
      
      if (nchar(widget_content) < 50) {
        message("Error: Extracted widget content is too small")
        return(create_error_message("Widget content extraction failed", theme))
      }
      
      message(paste0("Widget content extracted, length: ", nchar(widget_content), " chars"))
      return(widget_content)
      
    }, error = function(e) {
      message(paste0("Error saving widget: ", e$message))
      return(create_error_message(paste0("Widget error: ", e$message), theme))
    })
    
  } else if (inherits(visualization, "grViz") || inherits(visualization, "DiagrammeR")) {
    message("Processing DiagrammeR/grViz widget...")
    # Convert DiagrammeR visualization to HTML - use fallback if it fails
    temp_file <- tempfile(fileext = ".html")
    tryCatch({
      htmlwidgets::saveWidget(
        visualization, 
        file = temp_file, 
        selfcontained = TRUE
      )
      widget_content <- readLines(temp_file, warn = FALSE)
      widget_content <- paste(widget_content, collapse = "\n")
      widget_content <- gsub(".*<body>", "", widget_content)
      widget_content <- gsub("</body>.*", "", widget_content)
      message("DiagrammeR content extracted successfully")
      return(widget_content)
    }, error = function(e) {
      message(paste0("Error with DiagrammeR widget: ", e$message))
      # Use ASCII fallback
      return(htmltools::doRenderTags(generate_ascii_diagram(func_name, metadata, theme)))
    })
  } else if (inherits(visualization, "shiny.tag") || inherits(visualization, "html")) {
    message("Processing HTML content...")
    # HTML content
    html_content <- htmltools::doRenderTags(visualization)
    message(paste0("HTML content rendered, length: ", nchar(html_content), " chars"))
    return(html_content)
  } else if (is.character(visualization)) {
    # ASCII fallback - convert to pre-formatted text
    return(htmltools::doRenderTags(htmltools::tags$pre(
      style = paste0(
        "background-color: ", colors$codeBackground, "; ",
        "color: ", colors$codeText, "; ",
        "padding: 15px; border-radius: 4px; overflow-x: auto;"
      ),
      visualization
    )))
  } else {
    # Unknown type, convert to string representation
    return(htmltools::doRenderTags(htmltools::tags$pre(
      style = paste0(
        "background-color: ", colors$codeBackground, "; ",
        "color: ", colors$codeText, "; ",
        "padding: 15px; border-radius: 4px; overflow-x: auto;"
      ),
      deparse(visualization)
    )))
  }
}

#' Generate a function diagram for the panel
#' 
#' @description Creates a specialized diagram showing function input and output flow
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @return HTML/SVG diagram of function data flow
#' @export
generate_function_diagram_panel <- function(func_name, metadata) {
  if (!requireNamespace("DiagrammeR", quietly = TRUE)) {
    return(generate_ascii_diagram(func_name, metadata))
  }
  
  # Extract arguments and return value
  args <- metadata$args %||% character(0)
  pkg <- metadata$package %||% "Unknown"
  returns <- metadata$returns %||% "Unknown"
  
  # Create the diagram
  dot_code <- paste0(
    "digraph G {\n",
    "  graph[rankdir=LR, bgcolor=\"transparent\", fontname=\"Arial\"];\n",
    "  node[fontname=\"Arial\", fontsize=12, shape=rect, style=filled, color=\"#4285F4\", fillcolor=\"#E8F0FE\"];\n",
    "  edge[fontname=\"Arial\", fontsize=10, color=\"#4285F4\"];\n\n",
    
    "  subgraph cluster_input {\n",
    "    label=\"Input\";\n",
    "    bgcolor=\"#F8F9FA\";\n",
    "    color=\"#DADCE0\";\n"
  )
  
  # Add input nodes
  for (i in seq_along(args)) {
    arg_name <- gsub("\\.", "_", args[i]) # DOT doesn't like dots in node names
    dot_code <- paste0(
      dot_code,
      "    arg_", i, " [label=\"", args[i], "\", shape=rect];\n"
    )
  }
  
  dot_code <- paste0(
    dot_code,
    "  }\n\n",
    
    "  function [label=\"", func_name, "\\n(", pkg, ")\", fillcolor=\"#4285F4\", fontcolor=\"white\", penwidth=2];\n\n",
    
    "  subgraph cluster_output {\n",
    "    label=\"Output\";\n",
    "    bgcolor=\"#F8F9FA\";\n",
    "    color=\"#DADCE0\";\n",
    "    return_val [label=\"", returns, "\", fillcolor=\"#E6F4EA\", color=\"#34A853\"];\n",
    "  }\n\n"
  )
  
  # Add edges from inputs to function
  for (i in seq_along(args)) {
    dot_code <- paste0(
      dot_code,
      "  arg_", i, " -> function;\n"
    )
  }
  
  # Add edge from function to output
  dot_code <- paste0(
    dot_code,
    "  function -> return_val;\n"
  )
  
  # Close the graph
  dot_code <- paste0(dot_code, "}\n")
  
  # Create graph using DiagrammeR
  return(DiagrammeR::grViz(dot_code))
}

#' Generate a data transformation visualization
#'
#' @description Creates a visualization showing how data is transformed by a function
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param sample_data Optional sample data to use in visualization
#' @param theme Color theme ("light" or "dark")
#' @return HTML visualization of data transformation
#' @export
generate_data_transformation_panel <- function(func_name, metadata, sample_data = NULL, theme = "light") {
  if (!requireNamespace("htmltools", quietly = TRUE)) {
    return(generate_ascii_data_flow(func_name, metadata, theme))
  }
  
  # Get colors based on theme
  colors <- get_theme_colors(theme)
  
  # Determine if this is a dplyr-like function
  pkg <- metadata$package %||% "Unknown"
  is_dplyr <- pkg %in% c("dplyr", "tidyr")
  is_filter <- grepl("filter", func_name, ignore.case = TRUE)
  
  # Create HTML container
  container <- htmltools::tags$div(
    style = paste0(
      "font-family: Arial; padding: 10px; ",
      "color: ", colors$text, ";"
    ),
    
    # Title
    htmltools::tags$h3(
      style = paste0(
        "color: ", colors$primary, "; ",
        "border-bottom: 1px solid ", colors$border, "; ",
        "padding-bottom: 8px;"
      ),
      paste0("Data Transformation: ", func_name)
    ),
    
    # Create a before/after visualization
    htmltools::tags$div(
      style = "display: flex; flex-direction: row; justify-content: space-between; margin-top: 20px;",
      
      # Before data
      htmltools::tags$div(
        style = "flex: 1; margin-right: 10px;",
        htmltools::tags$h4(
          style = paste0("color: ", colors$secondary, "; margin-bottom: 10px;"),
          "Before"
        ),
        create_data_table(get_sample_data("before", func_name, is_dplyr, is_filter), NULL, colors)
      ),
      
      # Arrow and function
      htmltools::tags$div(
        style = paste0(
          "display: flex; flex-direction: column; justify-content: center; ",
          "align-items: center; padding: 0 20px;"
        ),
        
        # Function box
        htmltools::tags$div(
          style = paste0(
            "background-color: ", colors$primary, "; ",
            "color: white; padding: 10px 15px; ",
            "border-radius: 4px; margin-bottom: 10px; font-weight: bold;"
          ),
          func_name
        ),
        
        # Arrow
        htmltools::tags$div(
          style = paste0("font-size: 24px; color: ", colors$primary, ";"),
          "→"
        ),
        
        # Code snippet
        htmltools::tags$pre(
          style = paste0(
            "background-color: ", colors$codeBackground, "; ",
            "color: ", colors$codeText, "; ",
            "padding: 8px; border-radius: 4px; ",
            "margin-top: 10px; font-size: 12px; max-width: 200px; overflow-x: auto;"
          ),
          htmltools::tags$code(
            get_example_code(func_name, is_dplyr, is_filter)
          )
        )
      ),
      
      # After data
      htmltools::tags$div(
        style = "flex: 1; margin-left: 10px;",
        htmltools::tags$h4(
          style = "color: #EA4335; margin-bottom: 10px;",
          "After"
        ),
        create_data_table(
          get_sample_data("after", func_name, is_dplyr, is_filter), 
          highlight = if(is_filter) c(1, 3) else NULL,
          colors = colors
        )
      )
    ),
    
    # Explanation
    htmltools::tags$div(
      style = paste0(
        "margin-top: 20px; padding: 15px; ",
        "background-color: ", colors$secondaryBg, "; ",
        "border-radius: 4px;"
      ),
      htmltools::tags$h4(
        style = paste0("color: ", colors$primary, "; margin-top: 0;"),
        "How it works"
      ),
      htmltools::tags$p(
        get_transformation_explanation(func_name, is_dplyr, is_filter)
      )
    )
  )
  
  return(container)
}

#' Create a styled data table for visualization
#'
#' @param data Data frame to display
#' @param highlight Row indices to highlight
#' @param colors Theme colors list
#' @return HTML table
#' @keywords internal
create_data_table <- function(data, highlight = NULL, colors) {
  # Default colors if not provided
  if (missing(colors) || is.null(colors)) {
    colors <- get_theme_colors("light")
  }
  
  # Get theme-specific colors
  border_color <- colors$border
  header_bg <- if (colors$background == "#1E1E1E") "#3D3D3D" else "#F1F3F4"
  highlight_bg <- if (colors$background == "#1E1E1E") "#3A3216" else "#FFF0E0"
  row_border <- border_color
  
  # Create table container
  table_html <- htmltools::tags$table(
    style = paste0(
      "width: 100%; border-collapse: collapse; font-size: 14px; ",
      "border: 1px solid ", border_color, "; border-radius: 4px; overflow: hidden; ",
      "color: ", colors$text, ";"
    ),
    
    # Table header
    htmltools::tags$thead(
      style = paste0("background-color: ", header_bg, ";"),
      htmltools::tags$tr(
        style = paste0("border-bottom: 2px solid ", border_color, ";"),
        lapply(names(data), function(col) {
          htmltools::tags$th(
            style = "padding: 8px 12px; text-align: left; font-weight: bold;",
            col
          )
        })
      )
    ),
    
    # Table body
    htmltools::tags$tbody(
      lapply(1:nrow(data), function(row) {
        # Determine if this row should be highlighted
        is_highlighted <- row %in% highlight
        row_style <- if(is_highlighted) {
          paste0(
            "border-bottom: 1px solid ", row_border, "; ",
            "background-color: ", highlight_bg, "; ",
            "font-weight: bold;"
          )
        } else {
          paste0("border-bottom: 1px solid ", row_border, ";")
        }
        
        htmltools::tags$tr(
          style = row_style,
          lapply(1:ncol(data), function(col) {
            htmltools::tags$td(
              style = "padding: 8px 12px;",
              as.character(data[row, col])
            )
          })
        )
      })
    )
  )
  
  return(table_html)
}

#' Get sample data based on function type
#'
#' @param stage "before" or "after"
#' @param func_name Function name
#' @param is_dplyr Is it a dplyr function?
#' @param is_filter Is it a filter-like function?
#' @return A data frame with sample data
#' @keywords internal
get_sample_data <- function(stage, func_name, is_dplyr, is_filter) {
  # Create sample data frame
  if (is_dplyr) {
    data <- data.frame(
      id = 1:5,
      name = c("Alice", "Bob", "Charlie", "David", "Eve"),
      age = c(25, 17, 32, 41, 19),
      score = c(85, 92, 78, 65, 91),
      stringsAsFactors = FALSE
    )
    
    # Transform based on function
    if (stage == "after") {
      if (is_filter) {
        # Filter out people under 21
        data <- data[data$age >= 21, ]
      } else if (grepl("select", func_name, ignore.case = TRUE)) {
        # Select only certain columns
        data <- data[, c("id", "name", "age")]
      } else if (grepl("mutate", func_name, ignore.case = TRUE)) {
        # Add a new column
        data$grade <- ifelse(data$score >= 90, "A", 
                           ifelse(data$score >= 80, "B",
                                ifelse(data$score >= 70, "C", "D")))
      } else if (grepl("arrange", func_name, ignore.case = TRUE)) {
        # Sort by age descending
        data <- data[order(-data$age), ]
      } else {
        # Generic transformation
        data$status <- "active"
      }
    }
  } else {
    # Generic data set for non-dplyr functions
    data <- data.frame(
      x = c(10, 20, 30, 40, 50),
      y = c(5, 15, 25, 35, 45),
      group = c("A", "A", "B", "B", "C"),
      stringsAsFactors = FALSE
    )
    
    if (stage == "after") {
      if (grepl("mean|sum|average", func_name, ignore.case = TRUE)) {
        # Statistical summary
        data <- aggregate(. ~ group, data = data, FUN = mean)
      } else if (grepl("plot|graph|chart", func_name, ignore.case = TRUE)) {
        # Keep the same data
      } else if (grepl("transform|convert", func_name, ignore.case = TRUE)) {
        # Transform data
        data$z <- data$x + data$y
      } else {
        # Generic transformation
        data$result <- data$x * 2
      }
    }
  }
  
  return(data)
}

#' Get example code for the function
#'
#' @param func_name Function name
#' @param is_dplyr Is it a dplyr function?
#' @param is_filter Is it a filter-like function?
#' @return Character string with example code
#' @keywords internal
get_example_code <- function(func_name, is_dplyr, is_filter) {
  if (is_dplyr) {
    if (is_filter) {
      return("data %>%\n  filter(age >= 21)")
    } else if (grepl("select", func_name, ignore.case = TRUE)) {
      return("data %>%\n  select(id, name, age)")
    } else if (grepl("mutate", func_name, ignore.case = TRUE)) {
      return("data %>%\n  mutate(\n    grade = case_when(\n      score >= 90 ~ \"A\",\n      score >= 80 ~ \"B\",\n      score >= 70 ~ \"C\",\n      TRUE ~ \"D\"\n    )\n  )")
    } else if (grepl("arrange", func_name, ignore.case = TRUE)) {
      return("data %>%\n  arrange(desc(age))")
    } else {
      return(paste0("data %>%\n  ", func_name, "()"))
    }
  } else {
    if (grepl("mean|sum|average", func_name, ignore.case = TRUE)) {
      return(paste0("aggregate(. ~ group, \n  data = data, \n  FUN = ", func_name, ")"))
    } else if (grepl("plot|graph|chart", func_name, ignore.case = TRUE)) {
      return(paste0(func_name, "(data$x, data$y, \n  col = data$group)"))
    } else {
      return(paste0("result <- ", func_name, "(data$x)"))
    }
  }
}

#' Get explanation text for the transformation
#'
#' @param func_name Function name
#' @param is_dplyr Is it a dplyr function?
#' @param is_filter Is it a filter-like function?
#' @return Character string with explanation
#' @keywords internal
get_transformation_explanation <- function(func_name, is_dplyr, is_filter) {
  if (is_dplyr) {
    if (is_filter) {
      return("The filter() function evaluates the condition (age >= 21) for each row in the data frame. Only rows where the condition is TRUE are kept in the output. In this example, only people aged 21 or older remain in the resulting data frame.")
    } else if (grepl("select", func_name, ignore.case = TRUE)) {
      return("The select() function chooses specific columns from the data frame while discarding others. In this example, only the 'id', 'name', and 'age' columns are kept in the output data frame.")
    } else if (grepl("mutate", func_name, ignore.case = TRUE)) {
      return("The mutate() function adds new columns to the data frame based on transformations of existing columns. In this example, a new 'grade' column is created based on the 'score' values, assigning letter grades using conditional logic.")
    } else if (grepl("arrange", func_name, ignore.case = TRUE)) {
      return("The arrange() function reorders rows in the data frame based on specified columns. When used with desc(), it sorts in descending order. In this example, rows are sorted by age from oldest to youngest.")
    } else {
      return(paste0("The ", func_name, "() function transforms the input data frame by applying operations to create a new data frame with the desired structure or contents."))
    }
  } else {
    if (grepl("mean|sum|average", func_name, ignore.case = TRUE)) {
      return(paste0("The ", func_name, "() function calculates summary statistics. When used with aggregate(), it computes the statistic for each group in the data. In this example, the mean value is calculated for each unique value in the 'group' column."))
    } else if (grepl("plot|graph|chart", func_name, ignore.case = TRUE)) {
      return(paste0("The ", func_name, "() function creates a visual representation of the data. This example plots x values against y values, with points colored according to their group."))
    } else {
      return(paste0("The ", func_name, "() function processes input data and produces transformed output based on its specific algorithm or calculation method."))
    }
  }
}

#' Create a new multimodal visualization interface
#'
#' @description Main function to generate the multimodal visualization interface
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param response_text AI response text
#' @param theme Color theme name ("light" or "dark") or custom list
#' @param visualization_types Vector of visualization types to include
#' @return HTML widget with the interface
#' @export
tldr_multimodal <- function(
  func_name,
  metadata = NULL,
  response_text = NULL,
  theme = "light",
  visualization_types = c("diagram", "data_flow", "code_highlight", "function_network")
) {
  # If metadata not provided, try to retrieve it
  if (is.null(metadata)) {
    # Check for package in func_name
    if (grepl("::", func_name, fixed = TRUE)) {
      parts <- strsplit(func_name, "::", fixed = TRUE)[[1]]
      pkg <- parts[1]
      func <- parts[2]
      metadata <- get_function_metadata(func, pkg)
    } else {
      metadata <- get_function_metadata(func_name)
    }
  }
  
  # If response text not provided, use a placeholder
  if (is.null(response_text)) {
    response_text <- paste0(
      "# ", func_name, "\n\n",
      "## Purpose\n",
      "This function is used for data manipulation.\n\n",
      "## Usage\n",
      "```r\n", func_name, "(data, ...)\n```\n\n",
      "## Key Arguments\n",
      "- `data`: The input data to process\n",
      "- `...`: Additional arguments\n\n",
      "## Examples\n",
      "```r\n",
      "# Basic example\n",
      "result <- ", func_name, "(my_data)\n",
      "```\n"
    )
  }
  
  # Create the multimodal interface
  widget <- create_multimodal_interface(
    func_name = func_name,
    metadata = metadata,
    response_text = response_text,
    visualization_types = visualization_types,
    theme = theme
  )
  
  return(widget)
}

# Helper functions

#' Capitalize first letter of each word
#' @param x Character string to capitalize
#' @return Capitalized string
#' @keywords internal
capitalize <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(toupper(substring(s, 1, 1)), substring(s, 2), sep = "", collapse = " ")
}

#' Null coalescing operator
#' @keywords internal
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}

#' Generate a function diagram for the panel
#' 
#' @description Creates a specialized diagram showing function input and output flow
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param theme Color theme ("light" or "dark")
#' @return HTML/SVG diagram of function data flow
#' @export
generate_function_diagram_panel <- function(func_name, metadata, theme = "light") {
  # Check for DiagrammeR and create ASCII fallback if not available
  if (!requireNamespace("DiagrammeR", quietly = TRUE)) {
    return(generate_ascii_diagram(func_name, metadata, theme))
  }
  
  # Extract arguments and return value
  args <- metadata$args %||% character(0)
  pkg <- metadata$package %||% "Unknown"
  returns <- metadata$returns %||% "Unknown"
  
  # Get colors based on theme
  if (theme == "dark") {
    bg_color <- "#1E1E1E"
    cluster_bg <- "#2D2D2D"
    cluster_color <- "#444444"
    node_color <- "#366B98"
    node_fill <- "#1E3A5F"
    func_fill <- "#4285F4"
    output_color <- "#34A853"
    output_fill <- "#1A3726"
    edge_color <- "#5D9FE1"
    font_color <- "#E8E8E8"
  } else {
    bg_color <- "transparent"
    cluster_bg <- "#F8F9FA"
    cluster_color <- "#DADCE0"
    node_color <- "#4285F4"
    node_fill <- "#E8F0FE"
    func_fill <- "#4285F4"
    output_color <- "#34A853"
    output_fill <- "#E6F4EA"
    edge_color <- "#4285F4"
    font_color <- "#333333"
  }
  
  # Create the diagram
  dot_code <- paste0(
    "digraph G {\n",
    "  graph[rankdir=LR, bgcolor=\"", bg_color, "\", fontname=\"Arial\"];\n",
    "  node[fontname=\"Arial\", fontsize=12, shape=rect, style=filled, fontcolor=\"", font_color, "\"];\n",
    "  edge[fontname=\"Arial\", fontsize=10, color=\"", edge_color, "\"];\n\n",
    
    "  subgraph cluster_input {\n",
    "    label=\"Input\";\n",
    "    bgcolor=\"", cluster_bg, "\";\n",
    "    color=\"", cluster_color, "\";\n",
    "    fontcolor=\"", font_color, "\";\n"
  )
  
  # Add input nodes
  for (i in seq_along(args)) {
    arg_name <- gsub("\\.", "_", args[i]) # DOT doesn't like dots in node names
    dot_code <- paste0(
      dot_code,
      "    arg_", i, " [label=\"", args[i], "\", shape=rect, color=\"", node_color, "\", fillcolor=\"", node_fill, "\"];\n"
    )
  }
  
  dot_code <- paste0(
    dot_code,
    "  }\n\n",
    
    "  function [label=\"", func_name, "\\n(", pkg, ")\", fillcolor=\"", func_fill, "\", fontcolor=\"white\", penwidth=2];\n\n",
    
    "  subgraph cluster_output {\n",
    "    label=\"Output\";\n",
    "    bgcolor=\"", cluster_bg, "\";\n",
    "    color=\"", cluster_color, "\";\n",
    "    fontcolor=\"", font_color, "\";\n",
    "    return_val [label=\"", returns, "\", fillcolor=\"", output_fill, "\", color=\"", output_color, "\"];\n",
    "  }\n\n"
  )
  
  # Add edges from inputs to function
  for (i in seq_along(args)) {
    dot_code <- paste0(
      dot_code,
      "  arg_", i, " -> function;\n"
    )
  }
  
  # Add edge from function to output
  dot_code <- paste0(
    dot_code,
    "  function -> return_val;\n"
  )
  
  # Close the graph
  dot_code <- paste0(dot_code, "}\n")
  
  # Create graph using DiagrammeR
  diagram <- DiagrammeR::grViz(dot_code, width = "100%", height = 400)
  
  # Set the theme-appropriate background for the widget container
  if (theme == "dark") {
    diagram <- htmlwidgets::onRender(diagram, "function(el, x) {
      el.closest('.html-widget').style.backgroundColor = '#1E1E1E';
    }")
  }
  
  return(diagram)
}

#' Generate a data transformation visualization
#'
#' @description Creates a visualization showing how data is transformed by a function
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param sample_data Optional sample data to use in visualization
#' @param theme Color theme ("light" or "dark")
#' @return HTML visualization of data transformation
#' @export
generate_data_transformation_panel <- function(func_name, metadata, sample_data = NULL, theme = "light") {
  if (!requireNamespace("htmltools", quietly = TRUE)) {
    return(generate_ascii_data_flow(func_name, metadata, theme))
  }
  
  # Get colors based on theme
  colors <- get_theme_colors(theme)
  
  # Determine if this is a dplyr-like function
  pkg <- metadata$package %||% "Unknown"
  is_dplyr <- pkg %in% c("dplyr", "tidyr")
  is_filter <- grepl("filter", func_name, ignore.case = TRUE)
  
  # Create HTML container
  container <- htmltools::tags$div(
    style = paste0(
      "font-family: Arial; padding: 10px; ",
      "color: ", colors$text, ";"
    ),
    
    # Title
    htmltools::tags$h3(
      style = paste0(
        "color: ", colors$primary, "; ",
        "border-bottom: 1px solid ", colors$border, "; ",
        "padding-bottom: 8px;"
      ),
      paste0("Data Transformation: ", func_name)
    ),
    
    # Create a before/after visualization
    htmltools::tags$div(
      style = "display: flex; flex-direction: row; justify-content: space-between; margin-top: 20px;",
      
      # Before data
      htmltools::tags$div(
        style = "flex: 1; margin-right: 10px;",
        htmltools::tags$h4(
          style = paste0("color: ", colors$secondary, "; margin-bottom: 10px;"),
          "Before"
        ),
        create_data_table(get_sample_data("before", func_name, is_dplyr, is_filter), NULL, colors)
      ),
      
      # Arrow and function
      htmltools::tags$div(
        style = paste0(
          "display: flex; flex-direction: column; justify-content: center; ",
          "align-items: center; padding: 0 20px;"
        ),
        
        # Function box
        htmltools::tags$div(
          style = paste0(
            "background-color: ", colors$primary, "; ",
            "color: white; padding: 10px 15px; ",
            "border-radius: 4px; margin-bottom: 10px; font-weight: bold;"
          ),
          func_name
        ),
        
        # Arrow
        htmltools::tags$div(
          style = paste0("font-size: 24px; color: ", colors$primary, ";"),
          "→"
        ),
        
        # Code snippet
        htmltools::tags$pre(
          style = paste0(
            "background-color: ", colors$codeBackground, "; ",
            "color: ", colors$codeText, "; ",
            "padding: 8px; border-radius: 4px; ",
            "margin-top: 10px; font-size: 12px; max-width: 200px; overflow-x: auto;"
          ),
          htmltools::tags$code(
            get_example_code(func_name, is_dplyr, is_filter)
          )
        )
      ),
      
      # After data
      htmltools::tags$div(
        style = "flex: 1; margin-left: 10px;",
        htmltools::tags$h4(
          style = "color: #EA4335; margin-bottom: 10px;",
          "After"
        ),
        create_data_table(
          get_sample_data("after", func_name, is_dplyr, is_filter), 
          highlight = if(is_filter) c(1, 3) else NULL,
          colors = colors
        )
      )
    ),
    
    # Explanation
    htmltools::tags$div(
      style = paste0(
        "margin-top: 20px; padding: 15px; ",
        "background-color: ", colors$secondaryBg, "; ",
        "border-radius: 4px;"
      ),
      htmltools::tags$h4(
        style = paste0("color: ", colors$primary, "; margin-top: 0;"),
        "How it works"
      ),
      htmltools::tags$p(
        get_transformation_explanation(func_name, is_dplyr, is_filter)
      )
    )
  )
  
  return(container)
}

#' Create a styled data table for visualization
#'
#' @param data Data frame to display
#' @param highlight Row indices to highlight
#' @param colors Theme colors list
#' @return HTML table
#' @keywords internal
create_data_table <- function(data, highlight = NULL, colors) {
  # Default colors if not provided
  if (missing(colors) || is.null(colors)) {
    colors <- get_theme_colors("light")
  }
  
  # Get theme-specific colors
  border_color <- colors$border
  header_bg <- if (colors$background == "#1E1E1E") "#3D3D3D" else "#F1F3F4"
  highlight_bg <- if (colors$background == "#1E1E1E") "#3A3216" else "#FFF0E0"
  row_border <- border_color
  
  # Create table container
  table_html <- htmltools::tags$table(
    style = paste0(
      "width: 100%; border-collapse: collapse; font-size: 14px; ",
      "border: 1px solid ", border_color, "; border-radius: 4px; overflow: hidden; ",
      "color: ", colors$text, ";"
    ),
    
    # Table header
    htmltools::tags$thead(
      style = paste0("background-color: ", header_bg, ";"),
      htmltools::tags$tr(
        style = paste0("border-bottom: 2px solid ", border_color, ";"),
        lapply(names(data), function(col) {
          htmltools::tags$th(
            style = "padding: 8px 12px; text-align: left; font-weight: bold;",
            col
          )
        })
      )
    ),
    
    # Table body
    htmltools::tags$tbody(
      lapply(1:nrow(data), function(row) {
        # Determine if this row should be highlighted
        is_highlighted <- row %in% highlight
        row_style <- if(is_highlighted) {
          paste0(
            "border-bottom: 1px solid ", row_border, "; ",
            "background-color: ", highlight_bg, "; ",
            "font-weight: bold;"
          )
        } else {
          paste0("border-bottom: 1px solid ", row_border, ";")
        }
        
        htmltools::tags$tr(
          style = row_style,
          lapply(1:ncol(data), function(col) {
            htmltools::tags$td(
              style = "padding: 8px 12px;",
              as.character(data[row, col])
            )
          })
        )
      })
    )
  )
  
  return(table_html)
}

#' Generate a function network visualization
#' @description Creates a visualization showing related functions in a network
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param theme Color theme ("light" or "dark")
#' @return HTML visualization of function network
#' @export
generate_function_network_panel <- function(func_name, metadata, theme = "light") {
  # Check for required packages
  if (!requireNamespace("DiagrammeR", quietly = TRUE) && 
      !requireNamespace("visNetwork", quietly = TRUE)) {
    ascii_viz <- generate_function_network_ascii(func_name, metadata, theme)
    return(ascii_viz)
  }
  
  # Extract metadata
  pkg <- metadata$package %||% "Unknown"
  
  # Get related functions
  related_funcs <- get_related_functions(func_name, pkg)
  
  # If no related functions found, use some generic placeholders
  if (length(related_funcs) == 0) {
    if (pkg == "dplyr") {
      related_funcs <- c("select", "mutate", "group_by", "summarize", "arrange")
    } else if (pkg == "ggplot2") {
      related_funcs <- c("geom_point", "geom_line", "aes", "theme", "facet_wrap")
    } else if (pkg == "base" || pkg == "stats") {
      related_funcs <- c("mean", "median", "var", "sum", "plot")
    } else {
      # Generic placeholders
      related_funcs <- c(
        paste0("related_", pkg, "_1"),
        paste0("related_", pkg, "_2"),
        paste0("related_", pkg, "_3"),
        paste0("related_", pkg, "_4")
      )
    }
  }
  
  # Limit to 5 related functions for better visualization
  if (length(related_funcs) > 5) {
    related_funcs <- related_funcs[1:5]
  }
  
  # Get colors based on theme
  if (theme == "dark") {
    bg_color <- "#1E1E1E"
    node_color <- "#366B98"
    node_fill <- "#1E3A5F"
    func_fill <- "#4285F4"
    edge_color <- "#5D9FE1"
    font_color <- "white"
    label_color <- "#E8E8E8"
  } else {
    bg_color <- "transparent"
    node_color <- "#4285F4"
    node_fill <- "#E8F0FE"
    func_fill <- "#4285F4"
    edge_color <- "#4285F4"
    font_color <- "white"
    label_color <- "#333333"
  }
  
  if (requireNamespace("visNetwork", quietly = TRUE)) {
    # Create nodes for the function network
    nodes <- data.frame(
      id = 1:(length(related_funcs) + 1),
      label = c(func_name, related_funcs),
      group = c("main", rep("related", length(related_funcs))),
      title = c(paste0("Main function: ", func_name), 
               paste0("Related function in ", pkg, " package: ", related_funcs)),
      shape = c("box", rep("ellipse", length(related_funcs))),
      shadow = c(TRUE, rep(FALSE, length(related_funcs))),
      color.background = c(func_fill, rep(node_fill, length(related_funcs))),
      color.border = c(node_color, rep(node_color, length(related_funcs))),
      borderWidth = c(3, rep(1, length(related_funcs))),
      font.color = c(font_color, rep(label_color, length(related_funcs)))
    )
    
    # Create edges connecting related functions
    edges <- data.frame(
      from = rep(1, length(related_funcs)),
      to = 2:(length(related_funcs) + 1),
      arrows = "to",
      smooth = TRUE,
      color = edge_color,
      width = 2
    )
    
    # Create the network visualization with interactive options
    network <- visNetwork::visNetwork(nodes, edges, width = "100%", height = 400) %>%
      visNetwork::visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
      visNetwork::visLayout(randomSeed = 123) # Consistent layout
    
    if (theme == "dark") {
      network <- network %>% 
        visNetwork::visOptions(highlightNearest = list(enabled = TRUE, degree = 1)) %>%
        htmlwidgets::onRender("function(el, x) {
          el.closest('.html-widget').style.backgroundColor = '#1E1E1E';
        }")
    }
    
    return(network)
  } else {
    # Fallback to DiagrammeR if visNetwork is not available
    dot_code <- paste0(
      "digraph func_network {\n",
      "  graph [bgcolor=\"", bg_color, "\", fontname=\"Arial\", rankdir=LR];\n",
      "  node [fontname=\"Arial\", fontcolor=\"", label_color, "\", style=filled];\n",
      "  edge [fontname=\"Arial\", color=\"", edge_color, "\"];\n\n",
      
      "  // Main function node\n",
      "  main [label=\"", func_name, "\", shape=box, fillcolor=\"", func_fill, "\", fontcolor=\"white\", penwidth=2];\n\n",
      
      "  // Related function nodes\n"
    )
    
    # Add each related function
    for (i in seq_along(related_funcs)) {
      func <- related_funcs[i]
      node_id <- paste0("rel", i)
      
      dot_code <- paste0(
        dot_code,
        "  ", node_id, " [label=\"", func, "\", shape=ellipse, fillcolor=\"", node_fill, "\"];\n",
        "  main -> ", node_id, " [penwidth=1.5];\n\n"
      )
    }
    
    # Close the graph
    dot_code <- paste0(dot_code, "}\n")
    
    # Create graph using DiagrammeR
    diagram <- DiagrammeR::grViz(dot_code, width = "100%", height = 400)
    
    # Set theme-appropriate background
    if (theme == "dark") {
      diagram <- htmlwidgets::onRender(diagram, "function(el, x) {
        el.closest('.html-widget').style.backgroundColor = '#1E1E1E';
      }")
    }
    
    return(diagram)
  }
}

#' Generate a code highlight visualization
#' @description Creates a visualization with syntax-highlighted code
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param theme Color theme ("light" or "dark")
#' @return HTML visualization with highlighted code
#' @export
generate_code_highlight_panel <- function(func_name, metadata, theme = "light") {
  # Get theme colors
  colors <- get_theme_colors(theme)
  
  # Check for required packages
  use_highlight_pkg <- requireNamespace("highlight", quietly = TRUE)
  
  # Extract metadata
  pkg <- metadata$package %||% "Unknown"
  args <- metadata$args %||% character(0)
  args_str <- paste(args, collapse = ", ")
  
  # Try to get actual function source code
  func_source <- get_function_source(func_name, pkg, args_str)
  
  # If we couldn't get the source, use predefined examples
  if (is.null(func_source)) {
    # Customize source code based on known packages
    if (pkg == "dplyr" && func_name == "filter") {
      func_source <- 'function(.data, ..., .by = NULL, .preserve = FALSE) {
  # Filter rows that match the given conditions
  # from package: dplyr

  if (!is.null(.by)) {
    # Group by specified columns first
    tmp <- group_by(.data, !!!.by)
    on.exit(unbind_groups(tmp))
  } else {
    tmp <- .data
  }

  # Evaluate filter conditions
  dots <- enquos(...)
  result <- filter_eval(tmp, dots, caller_env())

  # Preserve grouping structure if requested
  if (.preserve && is_grouped_df(.data)) {
    result <- preserve_grouping(result, .data)
  }

  return(result)
}'
    } else if (pkg == "ggplot2" && func_name == "ggplot") {
      func_source <- 'function(data = NULL, mapping = aes(), ..., environment = parent.frame()) {
  # Create a new ggplot object
  # from package: ggplot2
  
  # Create the plot object
  p <- structure(list(
    data = data,
    layers = list(),
    scales = scales_list(),
    mapping = mapping,
    theme = list(),
    coordinates = coord_cartesian(),
    facet = facet_null(),
    plot_env = environment
  ), class = c("gg", "ggplot"))

  # Add any additional parameters
  p <- ggplot_add(dots(...), p, list(...))
  
  # Assign default theme
  p$theme <- theme_get()
  
  # Set options and return
  set_last_plot(p)
  return(p)
}'
    } else {
      # Default generic function body
      func_source <- paste0('function(', args_str, ') {
  # Function implementation for ', func_name, '
  # From package: ', pkg, '
  
  # Process inputs
  args <- list(...)
  
  # Execute function logic
  result <- process_data(data)
  
  # Return output
  return(result)
}')
    }
  }
  
  # Create the HTML for the code
  if (use_highlight_pkg) {
    # Use the highlight package for syntax highlighting
    temp_file <- tempfile(fileext = ".R")
    writeLines(func_source, temp_file)
    
    # Suppress warnings from highlight package
    old_warn <- options(warn = -1)
    on.exit(options(old_warn))
    
    # Apply theme-specific renderer
    renderer <- if (theme == "dark") {
      highlight::renderer_html(doc = FALSE, 
background = colors$codeBackground,
highlight = list(background = "#264F78"))
    } else {
      highlight::renderer_html(doc = FALSE)
    }
    
    # Create highlighted HTML
    highlighted <- highlight::highlight(file = temp_file, renderer = renderer)
    html_code <- htmltools::HTML(highlighted)
    
    # Clean up
    unlink(temp_file)
  } else {
    # Manual fallback - create syntax highlighting manually
    # This is a simple version without full syntax highlighting
    html_code <- htmltools::pre(
      style = paste0(
        "background-color: ", colors$codeBackground, "; ",
        "color: ", colors$codeText, "; ",
        "padding: 15px; border-radius: 4px; overflow-x: auto; ",
        "font-family: 'Consolas', 'Monaco', monospace; line-height: 1.5;"
      ),
      htmltools::code(func_source)
    )
  }
  
  # Create the container
  container <- htmltools::div(
    style = paste0(
      "padding: 20px; ",
      "background-color: ", colors$background, "; ",
      "color: ", colors$text, ";"
    ),
    
    # Header
    htmltools::h3(
      style = paste0("color: ", colors$primary, "; margin-bottom: 15px;"),
      paste0("Source Code: ", func_name, " (", pkg, " package)")
    ),
    
    # Code display
    htmltools::div(
      style = paste0(
        "border: 1px solid ", colors$border, "; ",
        "border-radius: 6px; overflow: hidden; ",
        "max-height: 400px; overflow-y: auto;"
      ),
      html_code
    ),
    
    # Usage note
    htmltools::div(
      style = paste0(
        "margin-top: 15px; padding: 10px; ",
        "background-color: ", colors$secondaryBg, "; ",
        "border-radius: 4px; font-size: 14px; ",
        "color: ", colors$secondaryText, ";"
      ),
      htmltools::p(
        htmltools::strong("Note: "),
        "This code may be simplified or adapted. Refer to package documentation for the complete implementation."
      )
    )
  )
  
  return(container)
}

#' Get function source code
#' @param func_name Function name
#' @param pkg Package name
#' @param args_str Arguments string for placeholder
#' @return Character string of function source code
#' @keywords internal
get_function_source <- function(func_name, pkg, args_str) {
  # Try to get the actual function source
  func_source <- tryCatch({
    # Handle special cases for base/internal functions
    if (pkg %in% c("base", "utils", "stats", "graphics")) {
      # Check if it's a primitive function
      f <- get(func_name, envir = asNamespace(pkg))
      if (is.primitive(f)) {
        return(paste0("function(", args_str, ") {\n  # This is a primitive function\n  # in package ", pkg, "\n  # Source code not available\n}"))
      }
    }
    
    # Try to get source code
    if (requireNamespace(pkg, quietly = TRUE)) {
      # Get the function from the package
      f <- get(func_name, envir = asNamespace(pkg))
      
      # For S3/S4 methods, follow the actual implementation
      if (inherits(f, "standardGeneric")) {
        return(paste0("function(", args_str, ") {\n  # This is an S4 generic function\n  # in package ", pkg, "\n  # Source code varies by method\n}"))
      }
      
      # Get the source code
      src <- deparse(f)
      if (length(src) > 0) {
        return(paste(src, collapse = "\n"))
      }
    }
    
    return(NULL)
  }, error = function(e) {
    return(NULL)
  })
  
  return(func_source)
}

# ASCII fallback functions
generate_ascii_diagram <- function(func_name, metadata, theme = "light") {
  message("Using ASCII fallback for function diagram")
  
  args <- metadata$args %||% character(0)
  pkg <- metadata$package %||% "Unknown"
  returns <- metadata$returns %||% "Result"
  
  # Create a simple ASCII diagram
  padding <- max(nchar(args), nchar(returns))
  
  # Input section
  ascii <- paste0(
    "Function: ", func_name, " (", pkg, ")\n"
  )
  
  ascii <- paste0(
    ascii,
    "┌", paste(rep("─", padding + 8), collapse = ""), "┐\n"
  )
  
  # Add arguments
  for (arg in args) {
    ascii <- paste0(
      ascii,
      "│ Input: ", arg, paste(rep(" ", padding - nchar(arg)), collapse = ""), " │\n"
    )
  }
  
  # Function box
  ascii <- paste0(
    ascii,
    "└", paste(rep("─", padding + 8), collapse = ""), "┘\n",
    "        ↓\n",
    "┌", paste(rep("─", padding + 8), collapse = ""), "┐\n",
    "│ ", func_name, paste(rep(" ", padding + 8 - nchar(func_name) - 1), collapse = ""), "│\n",
    "└", paste(rep("─", padding + 8), collapse = ""), "┘\n",
    "        ↓\n",
    "┌", paste(rep("─", padding + 8), collapse = ""), "┐\n",
    "│ Output: ", returns, paste(rep(" ", padding - nchar(returns)), collapse = ""), " │\n",
    "└", paste(rep("─", padding + 8), collapse = ""), "┘"
  )
  
  # Create HTML with theme-appropriate styling
  colors <- get_theme_colors(theme)
  pre_element <- htmltools::tags$pre(
    style = paste0(
      "background-color: ", colors$codeBackground, "; ",
      "color: ", colors$codeText, "; ",
      "padding: 15px; border-radius: 4px; overflow-x: auto; ",
      "font-family: 'Consolas', 'Monaco', monospace; line-height: 1.2;"
    ),
    ascii
  )
  
  return(pre_element)
}

generate_ascii_data_flow <- function(func_name, metadata, theme = "light") {
  message("Using ASCII fallback for data flow diagram")
  
  ascii <- paste0(
    "┌───────────┐     ┌───────────┐     ┌───────────┐\n",
    "│ Input Data│────>│ ", sprintf("%-9s", paste0(func_name, "()")), "│────>│ Output Data│\n",
    "└───────────┘     └───────────┘     └───────────┘"
  )
  
  # Create HTML with theme-appropriate styling
  colors <- get_theme_colors(theme)
  pre_element <- htmltools::tags$pre(
    style = paste0(
      "background-color: ", colors$codeBackground, "; ",
      "color: ", colors$codeText, "; ",
      "padding: 15px; border-radius: 4px; overflow-x: auto; ",
      "font-family: 'Consolas', 'Monaco', monospace; line-height: 1.2;"
    ),
    ascii
  )
  
  return(pre_element)
}

generate_function_network_ascii <- function(func_name, metadata, theme = "light") {
  message("Using ASCII fallback for function network")
  
  ascii <- paste0(
    "         ┌───────────────┐\n",
    "         │ ", sprintf("%-13s", func_name), "│\n",
    "         └───────┬───────┘\n",
    "          ┌──────┴───────┐\n",
    "          │              │\n",
    "┌─────────▼──────┐ ┌─────▼──────────┐\n",
    "│ Related Func 1 │ │ Related Func 2 │\n",
    "└────────────────┘ └────────────────┘"
  )
  
  # Create HTML with theme-appropriate styling
  colors <- get_theme_colors(theme)
  pre_element <- htmltools::tags$pre(
    style = paste0(
      "background-color: ", colors$codeBackground, "; ",
      "color: ", colors$codeText, "; ",
      "padding: 15px; border-radius: 4px; overflow-x: auto; ",
      "font-family: 'Consolas', 'Monaco', monospace; line-height: 1.2;"
    ),
    ascii
  )
  
  return(pre_element)
}