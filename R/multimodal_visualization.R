# Multi-modal visualization interface for tldrAI
# This module provides a two-panel integrated interface combining
# text documentation and interactive visualizations.

#' Create a multi-modal interface for function documentation
#'
#' @description 
#' Creates a modern HTML-based two-panel interface with text documentation on the left
#' and tabbed visualizations on the right. The interface is designed to be both
#' visually appealing and informative.
#'
#' @param func_name Name of the function 
#' @param metadata Function metadata including arguments, description, etc.
#' @param response_text Formatted text response from AI
#' @param visualization_types Character vector of visualization types to include in tabs
#' @param theme Color theme to use ("light", "dark", or a custom list of colors)
#' @param width Overall width of the interface in pixels
#' @param height Overall height of the interface in pixels
#'
#' @return An htmlwidget object that can be displayed in RStudio or browser
#' 
#' @importFrom htmlwidgets createWidget
#' @importFrom htmltools tags div h1 h2 h3 p code pre tagList HTML
#' @export
create_multimodal_interface <- function(
  func_name, 
  metadata, 
  response_text,
  visualization_types = c("diagram", "data_flow", "code_highlight", "function_network"),
  theme = "light",
  width = NULL, 
  height = 600
) {
  # Check required packages
  if (!requireNamespace("htmltools", quietly = TRUE) || 
      !requireNamespace("htmlwidgets", quietly = TRUE)) {
    message("MultiModal visualization requires the 'htmltools' and 'htmlwidgets' packages.")
    message("Please install them with: install.packages(c(\"htmltools\", \"htmlwidgets\"))")
    return(NULL)
  }
  
  # Get theme colors
  colors <- get_theme_colors(theme)
  
  # Create the interface container
  interface <- htmltools::tags$div(
    class = "tldrAI-multimodal-container",
    style = paste0(
      "display: flex; flex-direction: row; font-family: 'Arial', sans-serif; ",
      "width: 100%; height: ", height, "px; ",
      "background-color: ", colors$background, "; ",
      "color: ", colors$text, "; ",
      "border-radius: 8px; overflow: hidden; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"
    ),
    
    # Header for the interface
    htmltools::tags$div(
      class = "tldrAI-header",
      style = paste0(
        "position: absolute; top: 0; left: 0; width: 100%; ",
        "background-color: ", colors$primary, "; ",
        "color: white; padding: 10px 20px; z-index: 10; ",
        "font-weight: bold; font-size: 16px; display: flex; ",
        "justify-content: space-between; align-items: center;"
      ),
      
      # Function name and package
      htmltools::tags$div(
        paste0(func_name, " - ", metadata$package, " package")
      ),
      
      # Generated info
      htmltools::tags$div(
        style = "font-size: 12px; font-weight: normal;",
        "Generated by tldrAI"
      )
    ),
    
    # Left panel - Text documentation
    htmltools::tags$div(
      class = "tldrAI-text-panel",
      style = paste0(
        "flex: 1; padding: 50px 20px 20px 20px; overflow-y: auto; ",
        "border-right: 1px solid ", colors$border, ";"
      ),
      format_response_text(response_text, colors)
    ),
    
    # Right panel - Visualization tabs
    htmltools::tags$div(
      class = "tldrAI-viz-panel",
      style = paste0(
        "flex: 1; padding: 50px 0 0 0; display: flex; flex-direction: column; ",
        "background-color: ", colors$background, ";"
      ),
      
      # Tab navigation
      htmltools::tags$div(
        class = "tldrAI-tabs",
        style = paste0(
          "display: flex; border-bottom: 1px solid ", colors$border, "; ",
          "background-color: ", colors$secondary, ";"
        ),
        create_tabs(visualization_types, colors)
      ),
      
      # Tab content area
      htmltools::tags$div(
        class = "tldrAI-tab-content",
        style = "flex: 1; overflow: hidden; position: relative;",
        create_tab_panels(func_name, metadata, visualization_types)
      )
    )
  )
  
  # Create widget with JavaScript for interactivity
  widget <- htmlwidgets::createWidget(
    name = "tldrAI_multimodal",
    x = list(
      interface = as.character(interface),
      tabs = visualization_types,
      func_name = func_name,
      metadata = metadata
    ),
    width = width,
    height = height,
    package = "tldrAI",
    dependencies = list(
      htmltools::htmlDependency(
        name = "tldrAI-multimodal",
        version = "0.1.0",
        src = system.file("htmlwidgets", package = "tldrAI"),
        script = "tldrAI-multimodal.js",
        stylesheet = "tldrAI-multimodal.css"
      )
    )
  )
  
  return(widget)
}

#' Format the AI response text for HTML display
#'
#' @param response_text Text response from AI
#' @param colors Theme colors list
#' @return HTML tags object with formatted content
#' @keywords internal
format_response_text <- function(response_text, colors) {
  # Check if the response is already in markdown format
  if (inherits(response_text, "html") || inherits(response_text, "shiny.tag")) {
    return(response_text)
  }
  
  # Extract code blocks
  content <- extract_code_block(response_text)
  
  # Split the content by lines
  lines <- strsplit(content, "\n")[[1]]
  
  # Process each line to create HTML elements
  html_elements <- list()
  in_code_block <- FALSE
  code_buffer <- character(0)
  current_list <- NULL
  
  for (i in seq_along(lines)) {
    line <- lines[i]
    
    # Check for top level headers (# Title)
    if (grepl("^#\\s+[^#]", line)) {
      if (in_code_block) {
        # Close previous code block
        html_elements <- c(html_elements, htmltools::tags$pre(
          style = paste0("background-color: ", colors$codeBackground, "; ",
                        "color: ", colors$codeText, "; ",
                        "padding: 10px; border-radius: 4px; overflow-x: auto;"),
          htmltools::tags$code(paste(code_buffer, collapse = "\n"))
        ))
        in_code_block <- FALSE
        code_buffer <- character(0)
      }
      
      title <- gsub("^#\\s+", "", line)
      html_elements <- c(html_elements, htmltools::tags$h1(
        style = paste0("color: ", colors$primary, "; margin-top: 20px; font-size: 1.5em;"),
        title
      ))
    }
    # Check for section headers (## Title)
    else if (grepl("^##\\s+", line)) {
      if (in_code_block) {
        # Close previous code block
        html_elements <- c(html_elements, htmltools::tags$pre(
          style = paste0("background-color: ", colors$codeBackground, "; ",
                        "color: ", colors$codeText, "; ",
                        "padding: 10px; border-radius: 4px; overflow-x: auto;"),
          htmltools::tags$code(paste(code_buffer, collapse = "\n"))
        ))
        in_code_block <- FALSE
        code_buffer <- character(0)
      }
      
      title <- gsub("^##\\s+", "", line)
      html_elements <- c(html_elements, htmltools::tags$h2(
        style = paste0("color: ", colors$secondary, "; margin-top: 15px; font-size: 1.3em;"),
        title
      ))
    }
    # Check for code blocks
    else if (grepl("^```", line)) {
      if (!in_code_block) {
        in_code_block <- TRUE
      } else {
        # Close code block
        html_elements <- c(html_elements, htmltools::tags$pre(
          style = paste0("background-color: ", colors$codeBackground, "; ",
                        "color: ", colors$codeText, "; ",
                        "padding: 10px; border-radius: 4px; overflow-x: auto;"),
          htmltools::tags$code(paste(code_buffer, collapse = "\n"))
        ))
        in_code_block <- FALSE
        code_buffer <- character(0)
      }
    }
    # Handle content within code blocks
    else if (in_code_block) {
      code_buffer <- c(code_buffer, line)
    }
    # Check for bullet points
    else if (grepl("^-\\s+", line)) {
      bullet_text <- gsub("^-\\s+", "", line)
      
      # Split by colon if present
      if (grepl(":", bullet_text)) {
        parts <- strsplit(bullet_text, ":\\s*", 2)[[1]]
        html_elements <- c(html_elements, htmltools::tags$p(
          style = "margin: 5px 0;",
          htmltools::tags$strong(style = paste0("color: ", colors$primary, ";"), paste0("• ", parts[1], ":")), 
          " ", parts[2]
        ))
      } else {
        html_elements <- c(html_elements, htmltools::tags$p(
          style = "margin: 5px 0;",
          htmltools::HTML(paste0("• ", bullet_text))
        ))
      }
    }
    # Handle inline code with backticks
    else if (grepl("`[^`]+`", line)) {
      # Replace inline code
      formatted_line <- gsub(
        "`([^`]+)`", 
        paste0("<code style='background-color: ", colors$codeBackground, "; ",
              "color: ", colors$codeText, "; padding: 2px 4px; border-radius: 3px;'>\\1</code>"), 
        line
      )
      html_elements <- c(html_elements, htmltools::tags$p(
        style = "margin: 7px 0;",
        htmltools::HTML(formatted_line)
      ))
    }
    # Regular text (skip empty lines)
    else if (nchar(trimws(line)) > 0) {
      html_elements <- c(html_elements, htmltools::tags$p(
        style = "margin: 7px 0;",
        line
      ))
    }
  }
  
  # In case there's still an open code block
  if (in_code_block && length(code_buffer) > 0) {
    html_elements <- c(html_elements, htmltools::tags$pre(
      style = paste0("background-color: ", colors$codeBackground, "; ",
                    "color: ", colors$codeText, "; ",
                    "padding: 10px; border-radius: 4px; overflow-x: auto;"),
      htmltools::tags$code(paste(code_buffer, collapse = "\n"))
    ))
  }
  
  return(htmltools::tagList(html_elements))
}

#' Create tab buttons for the visualization panel
#'
#' @param visualization_types Vector of visualization types
#' @param colors Theme colors list
#' @return HTML tags list with tab buttons
#' @keywords internal
create_tabs <- function(visualization_types, colors) {
  tab_elements <- list()
  
  # Tab display names - more user-friendly than internal names
  tab_names <- list(
    diagram = "Function Diagram",
    flowchart = "Flowchart",
    data_flow = "Data Flow",
    function_network = "Function Network",
    code_highlight = "Code"
  )
  
  # Create a tab for each visualization type
  for (i in seq_along(visualization_types)) {
    type <- visualization_types[i]
    display_name <- tab_names[[type]] %||% capitalize(gsub("_", " ", type))
    
    # The first tab is active by default
    is_active <- i == 1
    active_class <- if(is_active) "tldrAI-tab-active" else ""
    
    tab_elements[[i]] <- htmltools::tags$div(
      class = paste("tldrAI-tab", active_class),
      id = paste0("tab-", type),
      `data-target` = paste0("panel-", type),
      style = paste0(
        "padding: 10px 15px; cursor: pointer; ",
        "border-bottom: 3px solid ", if(is_active) colors$accent else "transparent", "; ",
        "transition: all 0.3s ease;"
      ),
      display_name
    )
  }
  
  return(htmltools::tagList(tab_elements))
}

#' Create tab content panels for each visualization
#'
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param visualization_types Vector of visualization types
#' @return HTML tags list with tab panels
#' @keywords internal
create_tab_panels <- function(func_name, metadata, visualization_types) {
  panel_elements <- list()
  
  # Create a content panel for each visualization type
  for (i in seq_along(visualization_types)) {
    type <- visualization_types[i]
    
    # The first panel is visible by default
    is_visible <- i == 1
    display_style <- if(is_visible) "block" else "none"
    
    # Create panel with loading indicator
    panel_elements[[i]] <- htmltools::tags$div(
      class = "tldrAI-tab-panel",
      id = paste0("panel-", type),
      style = paste0(
        "position: absolute; top: 0; left: 0; width: 100%; height: 100%; ",
        "overflow: auto; padding: 15px; display: ", display_style, ";"
      ),
      
      # Loading indicator (replaced by actual visualization via JavaScript)
      htmltools::tags$div(
        class = "tldrAI-loading",
        style = paste0(
          "display: flex; flex-direction: column; ",
          "justify-content: center; align-items: center; ",
          "height: 100%; width: 100%;"
        ),
        
        htmltools::tags$div(
          style = paste0(
            "border: 3px solid #f3f3f3; border-top: 3px solid #3498db; ",
            "border-radius: 50%; width: 30px; height: 30px; animation: spin 2s linear infinite; ",
            "@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); }}"
          )
        ),
        
        htmltools::tags$p(
          style = "margin-top: 15px;",
          paste0("Loading ", gsub("_", " ", type), " visualization...")
        )
      ),
      
      # Placeholder for the visualization
      htmltools::tags$div(
        class = "tldrAI-visualization-container",
        id = paste0("viz-", type),
        `data-type` = type,
        `data-func` = func_name,
        style = "height: 100%; width: 100%;"
      )
    )
  }
  
  return(htmltools::tagList(panel_elements))
}

#' Get colors for the specified theme
#'
#' @param theme Theme name or custom color list
#' @return List of colors for the interface
#' @keywords internal
get_theme_colors <- function(theme) {
  if (is.list(theme)) {
    # Custom theme provided as a list
    defaults <- list(
      primary = "#4285F4",       # Primary color (headers, highlights)
      secondary = "#34A853",     # Secondary color (sub-headers)
      accent = "#FBBC05",        # Accent color (active tabs, buttons)
      background = "#FFFFFF",    # Background color
      secondaryBg = "#F5F5F5",   # Secondary background (tabs, panels)
      text = "#333333",          # Main text color
      secondaryText = "#666666", # Secondary text color
      border = "#DDDDDD",        # Border color
      codeBackground = "#F5F7F9", # Code block background
      codeText = "#24292E"       # Code text color
    )
    return(modifyList(defaults, theme))
  }
  
  # Predefined themes
  if (theme == "dark") {
    return(list(
      primary = "#4285F4",
      secondary = "#34A853",
      accent = "#FBBC05",
      background = "#1E1E1E",
      secondaryBg = "#2D2D2D",
      text = "#E8E8E8",
      secondaryText = "#BBBBBB",
      border = "#444444",
      codeBackground = "#2D2D30",
      codeText = "#D4D4D4"
    ))
  }
  
  # Default light theme
  return(list(
    primary = "#4285F4",
    secondary = "#34A853", 
    accent = "#FBBC05",
    background = "#FFFFFF",
    secondaryBg = "#F5F5F5",
    text = "#333333",
    secondaryText = "#666666",
    border = "#DDDDDD",
    codeBackground = "#F5F7F9",
    codeText = "#24292E"
  ))
}

#' Load a visualization into a tab panel
#'
#' @description Function called by JavaScript to generate visualization for a tab
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param vis_type Type of visualization to generate
#' @return HTML representation of the visualization
#' @export
load_visualization_tab <- function(func_name, metadata, vis_type) {
  # Create visualization handler
  handler <- VisualizationHandler$new()
  
  # Generate the visualization
  visualization <- handler$generate_visualization(func_name, metadata, vis_type, prompt_install = FALSE)
  
  # Convert visualization to HTML
  if (is.null(visualization)) {
    return(htmltools::tags$div(
      class = "tldrAI-error",
      style = "color: #D32F2F; text-align: center; padding: 20px;",
      htmltools::tags$p(
        style = "font-size: 16px; margin-bottom: 10px;",
        "Visualization failed to load"
      ),
      htmltools::tags$p(
        "Please ensure required packages are installed for this visualization type."
      )
    ))
  }
  
  # Handle different visualization types
  if (inherits(visualization, "htmlwidget")) {
    # Already an HTML widget, return as is
    return(visualization)
  } else if (inherits(visualization, "grViz") || inherits(visualization, "DiagrammeR")) {
    # DiagrammeR visualization
    return(visualization)
  } else if (inherits(visualization, "shiny.tag") || inherits(visualization, "html")) {
    # HTML content
    return(visualization)
  } else if (is.character(visualization)) {
    # ASCII fallback - convert to pre-formatted text
    return(htmltools::tags$pre(
      style = "background-color: #F5F7F9; padding: 15px; border-radius: 4px; overflow-x: auto;",
      visualization
    ))
  } else {
    # Unknown type, convert to string representation
    return(htmltools::tags$pre(
      style = "background-color: #F5F7F9; padding: 15px; border-radius: 4px; overflow-x: auto;",
      deparse(visualization)
    ))
  }
}

#' Generate a function diagram for the panel
#' 
#' @description Creates a specialized diagram showing function input and output flow
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @return HTML/SVG diagram of function data flow
#' @export
generate_function_diagram_panel <- function(func_name, metadata) {
  if (!requireNamespace("DiagrammeR", quietly = TRUE)) {
    return(generate_ascii_diagram(func_name, metadata))
  }
  
  # Extract arguments and return value
  args <- metadata$args %||% character(0)
  pkg <- metadata$package %||% "Unknown"
  returns <- metadata$returns %||% "Unknown"
  
  # Create the diagram
  dot_code <- paste0(
    "digraph G {\n",
    "  graph[rankdir=LR, bgcolor=\"transparent\", fontname=\"Arial\"];\n",
    "  node[fontname=\"Arial\", fontsize=12, shape=rect, style=filled, color=\"#4285F4\", fillcolor=\"#E8F0FE\"];\n",
    "  edge[fontname=\"Arial\", fontsize=10, color=\"#4285F4\"];\n\n",
    
    "  subgraph cluster_input {\n",
    "    label=\"Input\";\n",
    "    bgcolor=\"#F8F9FA\";\n",
    "    color=\"#DADCE0\";\n"
  )
  
  # Add input nodes
  for (i in seq_along(args)) {
    arg_name <- gsub("\\.", "_", args[i]) # DOT doesn't like dots in node names
    dot_code <- paste0(
      dot_code,
      "    arg_", i, " [label=\"", args[i], "\", shape=rect];\n"
    )
  }
  
  dot_code <- paste0(
    dot_code,
    "  }\n\n",
    
    "  function [label=\"", func_name, "\\n(", pkg, ")\", fillcolor=\"#4285F4\", fontcolor=\"white\", penwidth=2];\n\n",
    
    "  subgraph cluster_output {\n",
    "    label=\"Output\";\n",
    "    bgcolor=\"#F8F9FA\";\n",
    "    color=\"#DADCE0\";\n",
    "    return_val [label=\"", returns, "\", fillcolor=\"#E6F4EA\", color=\"#34A853\"];\n",
    "  }\n\n"
  )
  
  # Add edges from inputs to function
  for (i in seq_along(args)) {
    dot_code <- paste0(
      dot_code,
      "  arg_", i, " -> function;\n"
    )
  }
  
  # Add edge from function to output
  dot_code <- paste0(
    dot_code,
    "  function -> return_val;\n"
  )
  
  # Close the graph
  dot_code <- paste0(dot_code, "}\n")
  
  # Create graph using DiagrammeR
  return(DiagrammeR::grViz(dot_code))
}

#' Generate a data transformation visualization
#'
#' @description Creates a visualization showing how data is transformed by a function
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param sample_data Optional sample data to use in visualization
#' @return HTML visualization of data transformation
#' @export
generate_data_transformation_panel <- function(func_name, metadata, sample_data = NULL) {
  if (!requireNamespace("htmltools", quietly = TRUE)) {
    return(generate_ascii_data_flow(func_name, metadata))
  }
  
  # Determine if this is a dplyr-like function
  pkg <- metadata$package %||% "Unknown"
  is_dplyr <- pkg %in% c("dplyr", "tidyr")
  is_filter <- grepl("filter", func_name, ignore.case = TRUE)
  
  # Create HTML container
  container <- htmltools::tags$div(
    style = "font-family: Arial; padding: 10px;",
    
    # Title
    htmltools::tags$h3(
      style = "color: #4285F4; border-bottom: 1px solid #DADCE0; padding-bottom: 8px;",
      paste0("Data Transformation: ", func_name)
    ),
    
    # Create a before/after visualization
    htmltools::tags$div(
      style = "display: flex; flex-direction: row; justify-content: space-between; margin-top: 20px;",
      
      # Before data
      htmltools::tags$div(
        style = "flex: 1; margin-right: 10px;",
        htmltools::tags$h4(
          style = "color: #34A853; margin-bottom: 10px;",
          "Before"
        ),
        create_data_table(get_sample_data("before", func_name, is_dplyr, is_filter))
      ),
      
      # Arrow and function
      htmltools::tags$div(
        style = paste0(
          "display: flex; flex-direction: column; justify-content: center; ",
          "align-items: center; padding: 0 20px;"
        ),
        
        # Function box
        htmltools::tags$div(
          style = paste0(
            "background-color: #4285F4; color: white; padding: 10px 15px; ",
            "border-radius: 4px; margin-bottom: 10px; font-weight: bold;"
          ),
          func_name
        ),
        
        # Arrow
        htmltools::tags$div(
          style = "font-size: 24px; color: #4285F4;",
          "→"
        ),
        
        # Code snippet
        htmltools::tags$pre(
          style = paste0(
            "background-color: #F5F7F9; padding: 8px; border-radius: 4px; ",
            "margin-top: 10px; font-size: 12px; max-width: 200px; overflow-x: auto;"
          ),
          htmltools::tags$code(
            get_example_code(func_name, is_dplyr, is_filter)
          )
        )
      ),
      
      # After data
      htmltools::tags$div(
        style = "flex: 1; margin-left: 10px;",
        htmltools::tags$h4(
          style = "color: #EA4335; margin-bottom: 10px;",
          "After"
        ),
        create_data_table(get_sample_data("after", func_name, is_dplyr, is_filter), 
                         highlight = if(is_filter) c(1, 3) else NULL)
      )
    ),
    
    # Explanation
    htmltools::tags$div(
      style = "margin-top: 20px; padding: 15px; background-color: #F8F9FA; border-radius: 4px;",
      htmltools::tags$h4(
        style = "color: #4285F4; margin-top: 0;",
        "How it works"
      ),
      htmltools::tags$p(
        get_transformation_explanation(func_name, is_dplyr, is_filter)
      )
    )
  )
  
  return(container)
}

#' Create a styled data table for visualization
#'
#' @param data Data frame to display
#' @param highlight Row indices to highlight
#' @return HTML table
#' @keywords internal
create_data_table <- function(data, highlight = NULL) {
  # Create table container
  table_html <- htmltools::tags$table(
    style = paste0(
      "width: 100%; border-collapse: collapse; font-size: 14px; ",
      "border: 1px solid #DADCE0; border-radius: 4px; overflow: hidden;"
    ),
    
    # Table header
    htmltools::tags$thead(
      style = "background-color: #F1F3F4;",
      htmltools::tags$tr(
        style = "border-bottom: 2px solid #DADCE0;",
        lapply(names(data), function(col) {
          htmltools::tags$th(
            style = "padding: 8px 12px; text-align: left; font-weight: bold;",
            col
          )
        })
      )
    ),
    
    # Table body
    htmltools::tags$tbody(
      lapply(1:nrow(data), function(row) {
        # Determine if this row should be highlighted
        is_highlighted <- row %in% highlight
        row_style <- if(is_highlighted) {
          paste0(
            "border-bottom: 1px solid #DADCE0; background-color: #FFF0E0; ",
            "font-weight: bold;"
          )
        } else {
          "border-bottom: 1px solid #DADCE0;"
        }
        
        htmltools::tags$tr(
          style = row_style,
          lapply(1:ncol(data), function(col) {
            htmltools::tags$td(
              style = "padding: 8px 12px;",
              as.character(data[row, col])
            )
          })
        )
      })
    )
  )
  
  return(table_html)
}

#' Get sample data based on function type
#'
#' @param stage "before" or "after"
#' @param func_name Function name
#' @param is_dplyr Is it a dplyr function?
#' @param is_filter Is it a filter-like function?
#' @return A data frame with sample data
#' @keywords internal
get_sample_data <- function(stage, func_name, is_dplyr, is_filter) {
  # Create sample data frame
  if (is_dplyr) {
    data <- data.frame(
      id = 1:5,
      name = c("Alice", "Bob", "Charlie", "David", "Eve"),
      age = c(25, 17, 32, 41, 19),
      score = c(85, 92, 78, 65, 91),
      stringsAsFactors = FALSE
    )
    
    # Transform based on function
    if (stage == "after") {
      if (is_filter) {
        # Filter out people under 21
        data <- data[data$age >= 21, ]
      } else if (grepl("select", func_name, ignore.case = TRUE)) {
        # Select only certain columns
        data <- data[, c("id", "name", "age")]
      } else if (grepl("mutate", func_name, ignore.case = TRUE)) {
        # Add a new column
        data$grade <- ifelse(data$score >= 90, "A", 
                           ifelse(data$score >= 80, "B",
                                ifelse(data$score >= 70, "C", "D")))
      } else if (grepl("arrange", func_name, ignore.case = TRUE)) {
        # Sort by age descending
        data <- data[order(-data$age), ]
      } else {
        # Generic transformation
        data$status <- "active"
      }
    }
  } else {
    # Generic data set for non-dplyr functions
    data <- data.frame(
      x = c(10, 20, 30, 40, 50),
      y = c(5, 15, 25, 35, 45),
      group = c("A", "A", "B", "B", "C"),
      stringsAsFactors = FALSE
    )
    
    if (stage == "after") {
      if (grepl("mean|sum|average", func_name, ignore.case = TRUE)) {
        # Statistical summary
        data <- aggregate(. ~ group, data = data, FUN = mean)
      } else if (grepl("plot|graph|chart", func_name, ignore.case = TRUE)) {
        # Keep the same data
      } else if (grepl("transform|convert", func_name, ignore.case = TRUE)) {
        # Transform data
        data$z <- data$x + data$y
      } else {
        # Generic transformation
        data$result <- data$x * 2
      }
    }
  }
  
  return(data)
}

#' Get example code for the function
#'
#' @param func_name Function name
#' @param is_dplyr Is it a dplyr function?
#' @param is_filter Is it a filter-like function?
#' @return Character string with example code
#' @keywords internal
get_example_code <- function(func_name, is_dplyr, is_filter) {
  if (is_dplyr) {
    if (is_filter) {
      return("data %>%\n  filter(age >= 21)")
    } else if (grepl("select", func_name, ignore.case = TRUE)) {
      return("data %>%\n  select(id, name, age)")
    } else if (grepl("mutate", func_name, ignore.case = TRUE)) {
      return("data %>%\n  mutate(\n    grade = case_when(\n      score >= 90 ~ \"A\",\n      score >= 80 ~ \"B\",\n      score >= 70 ~ \"C\",\n      TRUE ~ \"D\"\n    )\n  )")
    } else if (grepl("arrange", func_name, ignore.case = TRUE)) {
      return("data %>%\n  arrange(desc(age))")
    } else {
      return(paste0("data %>%\n  ", func_name, "()"))
    }
  } else {
    if (grepl("mean|sum|average", func_name, ignore.case = TRUE)) {
      return(paste0("aggregate(. ~ group, \n  data = data, \n  FUN = ", func_name, ")"))
    } else if (grepl("plot|graph|chart", func_name, ignore.case = TRUE)) {
      return(paste0(func_name, "(data$x, data$y, \n  col = data$group)"))
    } else {
      return(paste0("result <- ", func_name, "(data$x)"))
    }
  }
}

#' Get explanation text for the transformation
#'
#' @param func_name Function name
#' @param is_dplyr Is it a dplyr function?
#' @param is_filter Is it a filter-like function?
#' @return Character string with explanation
#' @keywords internal
get_transformation_explanation <- function(func_name, is_dplyr, is_filter) {
  if (is_dplyr) {
    if (is_filter) {
      return("The filter() function evaluates the condition (age >= 21) for each row in the data frame. Only rows where the condition is TRUE are kept in the output. In this example, only people aged 21 or older remain in the resulting data frame.")
    } else if (grepl("select", func_name, ignore.case = TRUE)) {
      return("The select() function chooses specific columns from the data frame while discarding others. In this example, only the 'id', 'name', and 'age' columns are kept in the output data frame.")
    } else if (grepl("mutate", func_name, ignore.case = TRUE)) {
      return("The mutate() function adds new columns to the data frame based on transformations of existing columns. In this example, a new 'grade' column is created based on the 'score' values, assigning letter grades using conditional logic.")
    } else if (grepl("arrange", func_name, ignore.case = TRUE)) {
      return("The arrange() function reorders rows in the data frame based on specified columns. When used with desc(), it sorts in descending order. In this example, rows are sorted by age from oldest to youngest.")
    } else {
      return(paste0("The ", func_name, "() function transforms the input data frame by applying operations to create a new data frame with the desired structure or contents."))
    }
  } else {
    if (grepl("mean|sum|average", func_name, ignore.case = TRUE)) {
      return(paste0("The ", func_name, "() function calculates summary statistics. When used with aggregate(), it computes the statistic for each group in the data. In this example, the mean value is calculated for each unique value in the 'group' column."))
    } else if (grepl("plot|graph|chart", func_name, ignore.case = TRUE)) {
      return(paste0("The ", func_name, "() function creates a visual representation of the data. This example plots x values against y values, with points colored according to their group."))
    } else {
      return(paste0("The ", func_name, "() function processes input data and produces transformed output based on its specific algorithm or calculation method."))
    }
  }
}

#' Create a new multimodal visualization interface
#'
#' @description Main function to generate the multimodal visualization interface
#' @param func_name Name of the function
#' @param metadata Function metadata
#' @param response_text AI response text
#' @param theme Color theme name ("light" or "dark") or custom list
#' @param visualization_types Vector of visualization types to include
#' @return HTML widget with the interface
#' @export
tldr_multimodal <- function(
  func_name,
  metadata = NULL,
  response_text = NULL,
  theme = "light",
  visualization_types = c("diagram", "data_flow", "code_highlight", "function_network")
) {
  # If metadata not provided, try to retrieve it
  if (is.null(metadata)) {
    # Check for package in func_name
    if (grepl("::", func_name, fixed = TRUE)) {
      parts <- strsplit(func_name, "::", fixed = TRUE)[[1]]
      pkg <- parts[1]
      func <- parts[2]
      metadata <- get_function_metadata(func, pkg)
    } else {
      metadata <- get_function_metadata(func_name)
    }
  }
  
  # If response text not provided, use a placeholder
  if (is.null(response_text)) {
    response_text <- paste0(
      "# ", func_name, "\n\n",
      "## Purpose\n",
      "This function is used for data manipulation.\n\n",
      "## Usage\n",
      "```r\n", func_name, "(data, ...)\n```\n\n",
      "## Key Arguments\n",
      "- `data`: The input data to process\n",
      "- `...`: Additional arguments\n\n",
      "## Examples\n",
      "```r\n",
      "# Basic example\n",
      "result <- ", func_name, "(my_data)\n",
      "```\n"
    )
  }
  
  # Create the multimodal interface
  widget <- create_multimodal_interface(
    func_name = func_name,
    metadata = metadata,
    response_text = response_text,
    visualization_types = visualization_types,
    theme = theme
  )
  
  return(widget)
}

# Helper functions

#' Capitalize first letter of each word
#' @param x Character string to capitalize
#' @return Capitalized string
#' @keywords internal
capitalize <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(toupper(substring(s, 1, 1)), substring(s, 2), sep = "", collapse = " ")
}

#' Null coalescing operator
#' @keywords internal
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}