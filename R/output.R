#' Print formatted tldr response
#'
#' @param response The raw response from the AI
#' @param func_name The name of the function
#' @param verbose Whether verbose output was requested
#' @param examples Number of examples requested
#' @param provider The LLM provider that generated the response
#' @param voice The character voice used (if any)
#'
#' @return Invisibly returns NULL
#' @keywords internal
print_tldr_response <- function(response, func_name, verbose, examples, 
                               provider = NULL, voice = NULL) {
  # Extract the code block content
  content <- extract_code_block(response)
  
  # Use cli to format the output nicely
  cat("\n")
  cli::cli_h1(paste0("tldrAI: ", func_name))
  
  # Print the content
  cat(format_content(content))
  
  # Add a footer
  cat("\n")
  provider_name <- provider %||% attr(response, "provider") %||% "claude"
  provider_display <- ifelse(provider_name == "claude", "Claude's API", "OpenAI's API")
  
  cli::cli_text("{.emph Generated by tldrAI using ", provider_display, "}")
  
  # Add character voice info if used
  voice_name <- voice %||% attr(response, "voice") %||% "none"
  if (voice_name != "none") {
    # Format voice name for display (replace underscores with spaces, capitalize words)
    display_voice <- gsub("_", " ", voice_name)
    display_voice <- gsub("(^|\\s)([a-z])", "\\1\\U\\2", display_voice, perl = TRUE)
    
    cli::cli_text("{.emph Character voice: ", display_voice, "}")
  }
  
  cat("\n")
  
  invisible(NULL)
}

#' Extract the content from code blocks in the response
#'
#' @param response The raw response from the AI
#'
#' @return Character string with the content from the code block
#' @keywords internal
extract_code_block <- function(response) {
  # Convert newlines to a temporary marker
  modified_response <- gsub("\n", "@@NEWLINE@@", response)
  
  # Extract text between triple backticks
  pattern <- "```(.*?)```"
  matches <- regmatches(modified_response, gregexpr(pattern, modified_response))[[1]]
  
  if (length(matches) == 0) {
    # If no code blocks found, return the whole response
    return(response)
  }
  
  # Convert the temporary marker back to newlines
  matches <- gsub("@@NEWLINE@@", "\n", matches)
  
  # Remove the backticks and any language specification
  content <- gsub("```[rR]?\\s*|```", "", matches[1])
  
  content
}

#' Format the content for display
#'
#' @param content The content to format
#'
#' @return Character string with the formatted content
#' @keywords internal
format_content <- function(content) {
  # Split the content by lines
  lines <- strsplit(content, "\n")[[1]]
  
  # Process each line
  formatted_lines <- character(length(lines))
  in_r_code_block <- FALSE
  
  for (i in seq_along(lines)) {
    line <- lines[i]
    
    # Check for section headers (## Title)
    if (grepl("^##\\s+", line)) {
      formatted_lines[i] <- cli::col_cyan(line)
    } 
    # Check for code blocks (```r)
    else if (grepl("^```r", line)) {
      in_r_code_block <- TRUE
      formatted_lines[i] <- ""
    }
    # Check for end of code blocks (```)
    else if (grepl("^```$", line)) {
      in_r_code_block <- FALSE
      formatted_lines[i] <- ""
    }
    # Format code differently
    else if (in_r_code_block) {
      formatted_lines[i] <- cli::col_yellow(line)
    }
    # Check for bullet points
    else if (grepl("^-\\s+", line)) {
      # Extract the bullet point text
      bullet_text <- gsub("^-\\s+", "", line)
      # Split by colon if present
      if (grepl(":", bullet_text)) {
        parts <- strsplit(bullet_text, ":\\s*", 2)[[1]]
        formatted_lines[i] <- paste0("- ", cli::col_green(parts[1]), ": ", parts[2])
      } else {
        formatted_lines[i] <- paste0("- ", bullet_text)
      }
    }
    # Regular text
    else {
      formatted_lines[i] <- line
    }
  }
  
  # Join the lines back together
  paste(formatted_lines, collapse = "\n")
}

#' Null-coalescing operator
#' @keywords internal
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}