#' Print formatted tldr response
#'
#' @param response The raw response from the AI
#' @param func_name The name of the function
#' @param verbose Whether verbose output was requested
#' @param examples Number of examples requested
#' @param provider The LLM provider that generated the response
#' @param voice The character voice used (if any)
#'
#' @return Invisibly returns NULL
#' @keywords internal
print_tldr_response <- function(response, func_name, verbose, examples, 
                               provider = NULL, voice = NULL) {
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Printing response for function: ", func_name)
    message("DEBUG: Raw response length: ", nchar(response))
  }
  
  # Extract the code block content
  content <- extract_code_block(response)
  
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Extracted content length: ", nchar(content))
  }
  
  # Use cli to format the output nicely
  cat("\n")
  cli::cli_h1(paste0("tldrAI: ", func_name))
  
  # Print the content
  formatted_content <- format_content(content)
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Formatted content length: ", nchar(formatted_content))
  }
  cat(formatted_content)
  
  # Add a footer
  cat("\n")
  provider_name <- provider %||% attr(response, "provider") %||% "claude"
  provider_display <- ifelse(provider_name == "claude", "Claude's API", "OpenAI's API")
  
  cli::cli_text("{.emph Generated by tldrAI using ", provider_display, "}")
  
  # Add character voice info if used
  voice_name <- voice %||% attr(response, "voice") %||% "none"
  if (voice_name != "none") {
    # Format voice name for display (replace underscores with spaces, capitalize words)
    display_voice <- gsub("_", " ", voice_name)
    display_voice <- gsub("(^|\\s)([a-z])", "\\1\\U\\2", display_voice, perl = TRUE)
    
    cli::cli_text("{.emph Character voice: ", display_voice, "}")
  }
  
  # Add context awareness info if used
  context_aware <- attr(response, "context_aware") %||% FALSE
  if (context_aware) {
    cli::cli_text("{.emph Context awareness: Enabled}")
  }
  
  cat("\n")
  
  invisible(NULL)
}

#' Extract the content from code blocks in the response
#'
#' @param response The raw response from the AI
#'
#' @return Character string with the content from the code block
#' @keywords internal
extract_code_block <- function(response) {
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Extracting code block from response")
    message("DEBUG: Response starts with: ", substr(response, 1, 50))
  }
  
  # Split the response into lines
  lines <- strsplit(response, "\n")[[1]]
  
  # Try to extract a code block, but if there are no clear markers, we'll process the whole thing as markdown
  
  # If response starts with a markdown heading, it's already formatted 
  if (grepl("^#\\s+", lines[1])) {
    if (get_config("debug_mode", default = FALSE)) {
      message("DEBUG: Response already in markdown format, returning whole response")
    }
    return(response)
  }
  
  # Find the main code block markers (first and last ````)
  code_block_markers <- which(grepl("^```", lines))
  
  if (length(code_block_markers) < 2) {
    if (get_config("debug_mode", default = FALSE)) {
      message("DEBUG: No code block markers found, returning whole response")
    }
    # If no code blocks found, return the whole response
    return(response)
  }
  
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Found ", length(code_block_markers), " code block markers")
    message("DEBUG: First marker at line ", code_block_markers[1])
    message("DEBUG: Last marker at line ", code_block_markers[length(code_block_markers)])
  }
  
  # Get the first and last markers (assuming the outer code block)
  start_marker <- code_block_markers[1]
  end_marker <- code_block_markers[length(code_block_markers)]
  
  # Extract the content between the markers
  content_lines <- lines[(start_marker + 1):(end_marker - 1)]
  
  # Join the lines back together
  content <- paste(content_lines, collapse = "\n")
  
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Extracted content starts with: ", substr(content, 1, 50))
  }
  
  # Process inner code blocks
  # Find and keep inner code blocks intact 
  inner_pattern <- "(```r.*?```)"
  if (grepl(inner_pattern, content, perl = TRUE)) {
    if (get_config("debug_mode", default = FALSE)) {
      message("DEBUG: Found inner code blocks")
    }
    # We'll transform the inner blocks to proper formatting later
    # in the format_content function
  }
  
  content
}

#' Format the content for display
#'
#' @param content The content to format
#'
#' @return Character string with the formatted content
#' @keywords internal
format_content <- function(content) {
  # Split the content by lines
  lines <- strsplit(content, "\n")[[1]]
  
  # Process each line
  formatted_lines <- character(length(lines))
  in_r_code_block <- FALSE
  
  for (i in seq_along(lines)) {
    line <- lines[i]
    
    # Check for top level headers (# Title) - color in bold green
    if (grepl("^#\\s+[^#]", line)) {
      formatted_lines[i] <- cli::col_green(cli::style_bold(line))
    }
    # Check for section headers (## Title)
    else if (grepl("^##\\s+", line)) {
      formatted_lines[i] <- cli::col_cyan(line)
    } 
    # Check for code blocks (```r)
    else if (grepl("^```r", line) || grepl("^```\\s*$", line)) {
      in_r_code_block <- TRUE
      formatted_lines[i] <- ""
    }
    # Check for end of code blocks (```)
    else if (grepl("^```$", line)) {
      in_r_code_block <- FALSE
      formatted_lines[i] <- ""
    }
    # Format code differently
    else if (in_r_code_block) {
      formatted_lines[i] <- cli::col_yellow(line)
    }
    # Check for bullet points
    else if (grepl("^-\\s+", line)) {
      # Extract the bullet point text
      bullet_text <- gsub("^-\\s+", "", line)
      # Split by colon if present
      if (grepl(":", bullet_text)) {
        parts <- strsplit(bullet_text, ":\\s*", 2)[[1]]
        formatted_lines[i] <- paste0("- ", cli::col_green(parts[1]), ": ", parts[2])
      } else {
        formatted_lines[i] <- paste0("- ", bullet_text)
      }
    }
    # Check for inline code with backticks
    else if (grepl("`[^`]+`", line)) {
      # Replace inline code with yellow color
      formatted_lines[i] <- gsub("`([^`]+)`", cli::col_yellow("\\1"), line, perl = TRUE)
    }
    # Regular text
    else {
      formatted_lines[i] <- line
    }
  }
  
  # Join the lines back together
  formatted_content <- paste(formatted_lines, collapse = "\n")
  
  # Handle any inner code blocks that may still be present
  # We split these out and format them with proper yellow coloring
  if (grepl("```r", formatted_content) || grepl("```$", formatted_content)) {
    # Replace inner code blocks with formatted versions
    lines <- strsplit(formatted_content, "\n")[[1]]
    in_code_block <- FALSE
    for (i in seq_along(lines)) {
      if (grepl("^```r", lines[i]) || grepl("^```\\s*$", lines[i])) {
        in_code_block <- TRUE
        lines[i] <- "" # Remove the opening ``` marker
      } else if (in_code_block && grepl("^```$", lines[i])) {
        in_code_block <- FALSE
        lines[i] <- "" # Remove the closing ``` marker
      } else if (in_code_block) {
        lines[i] <- cli::col_yellow(lines[i]) # Color code in yellow
      }
    }
    formatted_content <- paste(lines, collapse = "\n")
  }
  
  formatted_content
}

#' Null-coalescing operator
#' @keywords internal
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}