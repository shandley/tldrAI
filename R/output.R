#' Print formatted tldr response
#'
#' @param response The raw response from the AI
#' @param func_name The name of the function
#' @param verbose Whether verbose output was requested
#' @param examples Number of examples requested
#' @param provider The LLM provider that generated the response
#' @param voice The character voice used (if any)
#' @param visualization Visualization handler object or NULL
#' @param multimodal Whether to use the multimodal visualization interface
#' @param theme Theme for multimodal interface ("light" or "dark")
#'
#' @return Invisibly returns NULL
#' @keywords internal
print_tldr_response <- function(response, func_name, verbose, examples, 
                               provider = NULL, voice = NULL, visualization = NULL,
                               multimodal = FALSE, theme = "light") {
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Printing response for function: ", func_name)
    message("DEBUG: Raw response length: ", nchar(response))
    message("DEBUG: Visualization provided: ", !is.null(visualization))
    message("DEBUG: Multimodal mode: ", multimodal)
  }
  
  # Extract the code block content
  content <- extract_code_block(response)
  
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Extracted content length: ", nchar(content))
  }
  
  # Get function metadata
  pkg <- NULL
  if (grepl("::", func_name, fixed = TRUE)) {
    parts <- strsplit(func_name, "::", fixed = TRUE)[[1]]
    pkg <- parts[1]
    func_name_only <- parts[2]
  } else {
    func_name_only <- func_name
  }
  
  metadata <- get_function_metadata(func_name_only, pkg)
  
  # Use multimodal interface if requested and packages are available
  if (multimodal && requireNamespace("htmlwidgets", quietly = TRUE) && 
      requireNamespace("htmltools", quietly = TRUE)) {
    # Determine available visualization types
    vis_types <- c("diagram", "data_flow", "function_network", "code_highlight")
    
    # Create multimodal interface
    interface <- tldr_multimodal(
      func_name = func_name, 
      metadata = metadata,
      response_text = content,
      theme = theme,
      visualization_types = vis_types
    )
    
    # Display the interface
    print(interface)
    
    # Skip the traditional output format
    return(invisible(NULL))
  }
  
  # Traditional console output format
  # Use cli to format the output nicely
  cat("\n")
  cli::cli_h1(paste0("tldrAI: ", func_name))
  
  # Print the content
  formatted_content <- format_content(content)
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Formatted content length: ", nchar(formatted_content))
  }
  cat(formatted_content)
  
  # Display visualization if available
  if (!is.null(visualization)) {
    cat("\n")
    cli::cli_h2("Visualization")
    
    # Print the visualization
    if (inherits(visualization, "VisualizationHandler") && !is.null(visualization$visualization_data$diagram)) {
      visualization$print()
    } else if (is.character(visualization)) {
      # Directly print ASCII visualizations
      cat(visualization)
      cat("\n")
    } else {
      # For any other type of visualization
      print(visualization)
    }
  }
  
  # Add a footer
  cat("\n")
  provider_name <- provider %||% attr(response, "provider") %||% "claude"
  provider_display <- ifelse(provider_name == "claude", "Claude's API", "OpenAI's API")
  
  cli::cli_text("{.emph Generated by tldrAI using ", provider_display, "}")
  
  # Add character voice info if used
  voice_name <- voice %||% attr(response, "voice") %||% "none"
  if (voice_name != "none") {
    # Format voice name for display (replace underscores with spaces, capitalize words)
    display_voice <- gsub("_", " ", voice_name)
    display_voice <- gsub("(^|\\s)([a-z])", "\\1\\U\\2", display_voice, perl = TRUE)
    
    cli::cli_text("{.emph Character voice: ", display_voice, "}")
  }
  
  # Add context awareness info if used
  context_aware <- attr(response, "context_aware") %||% FALSE
  if (context_aware) {
    cli::cli_text("{.emph Context awareness: Enabled}")
  }
  
  # Add visualization info if used
  if (!is.null(visualization) && inherits(visualization, "VisualizationHandler") && 
      !is.null(visualization$visualization_data$vis_type)) {
    vis_type <- visualization$visualization_data$vis_type
    # Format visualization type for display (replace underscores with spaces, capitalize words)
    display_vis_type <- gsub("_", " ", vis_type)
    display_vis_type <- gsub("(^|\\s)([a-z])", "\\1\\U\\2", display_vis_type, perl = TRUE)
    
    cli::cli_text("{.emph Visualization: ", display_vis_type, "}")
  }
  
  cat("\n")
  
  invisible(NULL)
}

#' Extract the content from code blocks in the response
#'
#' @param response The raw response from the AI
#'
#' @return Character string with the content from the code block
#' @keywords internal
extract_code_block <- function(response) {
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Extracting code block from response")
    message("DEBUG: Response starts with: ", substr(response, 1, 50))
  }
  
  # Split the response into lines
  lines <- strsplit(response, "\n")[[1]]
  
  # Try to extract a code block, but if there are no clear markers, we'll process the whole thing as markdown
  
  # If response starts with a markdown heading, it's already formatted 
  if (grepl("^#\\s+", lines[1])) {
    if (get_config("debug_mode", default = FALSE)) {
      message("DEBUG: Response already in markdown format, returning whole response")
    }
    return(response)
  }
  
  # Find the main code block markers (first and last ````)
  code_block_markers <- which(grepl("^```", lines))
  
  if (length(code_block_markers) < 2) {
    if (get_config("debug_mode", default = FALSE)) {
      message("DEBUG: No code block markers found, returning whole response")
    }
    # If no code blocks found, return the whole response
    return(response)
  }
  
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Found ", length(code_block_markers), " code block markers")
    message("DEBUG: First marker at line ", code_block_markers[1])
    message("DEBUG: Last marker at line ", code_block_markers[length(code_block_markers)])
  }
  
  # Get the first and last markers (assuming the outer code block)
  start_marker <- code_block_markers[1]
  end_marker <- code_block_markers[length(code_block_markers)]
  
  # Extract the content between the markers
  content_lines <- lines[(start_marker + 1):(end_marker - 1)]
  
  # Join the lines back together
  content <- paste(content_lines, collapse = "\n")
  
  if (get_config("debug_mode", default = FALSE)) {
    message("DEBUG: Extracted content starts with: ", substr(content, 1, 50))
  }
  
  # Process inner code blocks
  # Find and keep inner code blocks intact 
  inner_pattern <- "(```r.*?```)"
  if (grepl(inner_pattern, content, perl = TRUE)) {
    if (get_config("debug_mode", default = FALSE)) {
      message("DEBUG: Found inner code blocks")
    }
    # We'll transform the inner blocks to proper formatting later
    # in the format_content function
  }
  
  content
}

#' Format the content for display
#'
#' @param content The content to format
#'
#' @return Character string with the formatted content
#' @keywords internal
format_content <- function(content) {
  # Split the content by lines
  lines <- strsplit(content, "\n")[[1]]
  
  # Process each line
  formatted_lines <- character(length(lines))
  in_r_code_block <- FALSE
  
  for (i in seq_along(lines)) {
    line <- lines[i]
    
    # Check for top level headers (# Title) - color in bold green
    if (grepl("^#\\s+[^#]", line)) {
      formatted_lines[i] <- cli::col_green(cli::style_bold(line))
    }
    # Check for section headers (## Title)
    else if (grepl("^##\\s+", line)) {
      formatted_lines[i] <- cli::col_cyan(line)
    } 
    # Check for code blocks (```r)
    else if (grepl("^```r", line) || grepl("^```\\s*$", line)) {
      in_r_code_block <- TRUE
      formatted_lines[i] <- ""
    }
    # Check for end of code blocks (```)
    else if (grepl("^```$", line)) {
      in_r_code_block <- FALSE
      formatted_lines[i] <- ""
    }
    # Format code differently
    else if (in_r_code_block) {
      formatted_lines[i] <- cli::col_yellow(line)
    }
    # Check for bullet points
    else if (grepl("^-\\s+", line)) {
      # Extract the bullet point text
      bullet_text <- gsub("^-\\s+", "", line)
      # Split by colon if present
      if (grepl(":", bullet_text)) {
        parts <- strsplit(bullet_text, ":\\s*", 2)[[1]]
        formatted_lines[i] <- paste0("- ", cli::col_green(parts[1]), ": ", parts[2])
      } else {
        formatted_lines[i] <- paste0("- ", bullet_text)
      }
    }
    # Check for inline code with backticks
    else if (grepl("`[^`]+`", line)) {
      # Replace inline code with yellow color
      formatted_lines[i] <- gsub("`([^`]+)`", cli::col_yellow("\\1"), line, perl = TRUE)
    }
    # Regular text
    else {
      formatted_lines[i] <- line
    }
  }
  
  # Join the lines back together
  formatted_content <- paste(formatted_lines, collapse = "\n")
  
  # Handle any inner code blocks that may still be present
  # We split these out and format them with proper yellow coloring
  if (grepl("```r", formatted_content) || grepl("```$", formatted_content)) {
    # Replace inner code blocks with formatted versions
    lines <- strsplit(formatted_content, "\n")[[1]]
    in_code_block <- FALSE
    for (i in seq_along(lines)) {
      if (grepl("^```r", lines[i]) || grepl("^```\\s*$", lines[i])) {
        in_code_block <- TRUE
        lines[i] <- "" # Remove the opening ``` marker
      } else if (in_code_block && grepl("^```$", lines[i])) {
        in_code_block <- FALSE
        lines[i] <- "" # Remove the closing ``` marker
      } else if (in_code_block) {
        lines[i] <- cli::col_yellow(lines[i]) # Color code in yellow
      }
    }
    formatted_content <- paste(lines, collapse = "\n")
  }
  
  formatted_content
}

#' Null-coalescing operator
#' @keywords internal
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}